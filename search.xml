<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 越狱开发实战2—将指定邮件标记为已读]]></title>
    <url>%2Fblog%2FiOS%20%E8%B6%8A%E7%8B%B1%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%982_%E5%B0%86%E6%8C%87%E5%AE%9A%E9%82%AE%E4%BB%B6%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%B7%B2%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[功能描述：Apple Mail iOS10.21.在Mail界面上的某个地方加个按钮，点击后出现可编辑的白名单列表，以便进行添加、删除白名单操作。2.每次Mail的收件箱刷新后,自动把白名单以外的邮件标记为已读。 MailAutoMarker定位Mail的可执行文件并class-dump它1➜ ~ class-dump -S -s -H /Users/vvusu/Downloads/Reverse/iOSREDemo/AutoMobileMail/MobileMail.app -o /Users/vvusu/Downloads/Reverse/iOSREDemo/AutoMobileMail/MobileMailHeader 用Cycript找到Mailboxes界面的controller方法一： 12345678910WSCN-6SP:~ root# cycript -p MobileMailcy# [[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()`&lt;MFApplicationSceneController 0x11c855400&gt;, state: appeared, view: &lt;UIView 0x11bd99ce0&gt; | &lt;MailSplitViewController 0x11bd99980&gt;, state: appeared, view: &lt;UILayoutContainerView 0x11bd96e60&gt; | | &lt;UIMultiColumnViewController 0x11bd99200&gt;, state: appeared, view: &lt;UIView 0x11bdb3c90&gt; | | | &lt;MailNavigationController 0x11c85c600&gt;, state: appeared, view: &lt;UILayoutContainerView 0x11bd51a40&gt; | | | | &lt;MailboxPickerController 0x11be36180&gt;, state: appeared, view: &lt;UITableView 0x11c063a00&gt; | | | &lt;UINavigationController 0x11c8d9800&gt;, state: disappeared, view: (view not loaded) | | &lt;MailDetailNavigationController 0x11c8b7a00&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x11bd97060&gt; not in the window | | | &lt;MFConversationViewController 0x11c802600&gt;, state: disappeared, view: &lt;UIView 0x11bd4f650&gt; not in the window` 方法二： 12345678910111213cy# [[UIApp keyWindow] recursiveDescription].toString()`&lt;MFWindow: 0x11dd45a40; baseClass = UIWindow; frame = (0 0; 414 736); autoresize = W+H; tintColor = UIExtendedSRGBColorSpace 0 0.478431 1 1; gestureRecognizers = &lt;NSArray: 0x174242c40&gt;; layer = &lt;UIWindowLayer: 0x174039680&gt;&gt; | &lt;UIView: 0x11dd76880; frame = (0 0; 414 736); opaque = NO; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x17025bd20&gt;; layer = &lt;CALayer: 0x17403e760&gt;&gt; | | &lt;UIView: 0x11dd4c340; frame = (0 0; 414 736); layer = &lt;CALayer: 0x17403d7c0&gt;&gt; | | | &lt;_MFActorItemView: 0x11dd7b100; frame = (0 0; 414 736); layer = &lt;CALayer: 0x170223be0&gt;&gt; | | | | &lt;UIView: 0x11de580e0; frame = (-0.666667 -0.666667; 415.333 737.333); alpha = 0; layer = &lt;CALayer: 0x170223ba0&gt;&gt; | | | | &lt;_MFActorSnapshotView: 0x11de58280; frame = (0 0; 414 736); opaque = NO; layer = &lt;CALayer: 0x170223ae0&gt;&gt; | | | | | &lt;UIImageView: 0x11de58640; frame = (0 0; 414 736); userInteractionEnabled = NO; layer = &lt;CALayer: 0x170223b00&gt;&gt; | | | | &lt;UILayoutContainerView: 0x11dd77030; frame = (0 0; 414 736); clipsToBounds = YES; opaque = NO; autoresize = LM+W+RM+TM+H+BM; gestureRecognizers = &lt;NSArray: 0x17025ae50&gt;; layer = &lt;CALayer: 0x17403d4c0&gt;&gt; | | | | | | &lt;MailboxTableCell: 0x11e882e00; baseClass = UITableViewCell; frame = (0 28; 414 44); text = &apos;Inbox&apos;; autoresize = W; layer = &lt;CALayer: 0x17422a860&gt;&gt; | | | | | | | &lt;UITableViewCellContentView: 0x11dd8fce0; frame = (0 0; 376 43.6667); gestureRecognizers = &lt;NSArray: 0x17425cc20&gt;; layer = &lt;CALayer: 0x17422a8a0&gt;&gt; | | | | | | | | &lt;UITableViewLabel: 0x11dd95d70; frame = (55 12; 305.333 20.3333); text = &apos;Inbox&apos;; userInteractionEnabled = NO; layer = &lt;_UILabelLayer: 0x174283bb0&gt;&gt;... 搜索页面中第一个titleInbox找到相关类MailboxTableCell 0x11e882e00 找到它的响应连。 123456cy# [#0x11e882e00 nextResponder]#&quot;&lt;UITableViewWrapperView: 0x11e87c200; frame = (0 0; 414 672); gestureRecognizers = &lt;NSArray: 0x17424fe40&gt;; layer = &lt;CALayer: 0x17403d3a0&gt;; contentOffset: &#123;0, 0&#125;; contentSize: &#123;414, 672&#125;&gt;&quot;cy# [#0x11e87c200 nextResponder]#&quot;&lt;UITableView: 0x11e896400; frame = (0 0; 414 736); clipsToBounds = YES; autoresize = W+H; gestureRecognizers = &lt;NSArray: 0x17424fb10&gt;; layer = &lt;CALayer: 0x17403f1a0&gt;; contentOffset: &#123;0, -64&#125;; contentSize: &#123;414, 560&#125;&gt;&quot;cy# [#0x11e896400 nextResponder]#&quot;&lt;MailboxPickerController: 0x11dd464a0&gt;&quot; 最终找到控制器MailboxPickerController测试修改Title。发现Title改变。 1cy# [#0x11dd464a0 setTitle:@&quot;vvusu&quot;] 测试修改导航栏左边按钮： 12cy# #0x125e47660.navigationItem.leftBarButtonItem = #0x125e47660.navigationItem.rightBarButtonItem#&quot;&lt;UIBarButtonItem: 0x125de57a0&gt;&quot; 确定MailboxPickerController就是Mailboxes界面的controller，可以通过它添加白名单按钮。 用Reveal和Cycript找到All Inboxes界面的 delegate点击进入Inbox页面，打印控制器列表。 12345678910cy# [[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()`&lt;MFApplicationSceneController 0x126896a00&gt;, state: appeared, view: &lt;UIView 0x125e575d0&gt; | &lt;MailSplitViewController 0x125d77db0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x125e5a820&gt; | | &lt;UIMultiColumnViewController 0x125d77630&gt;, state: appeared, view: &lt;UIView 0x125e68210&gt; | | | &lt;MailNavigationController 0x12684c800&gt;, state: appeared, view: &lt;UILayoutContainerView 0x125e47f30&gt; | | | | &lt;MailboxPickerController 0x125e47660&gt;, state: disappeared, view: &lt;UITableView 0x126872000&gt; not in the window | | | | &lt;MailboxContentViewController 0x126048c00&gt;, state: appeared, view: &lt;MFSwipableTableView 0x126855000&gt; | | | &lt;UINavigationController 0x12606cc00&gt;, state: disappeared, view: (view not loaded) | | &lt;MailDetailNavigationController 0x126893400&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x125e58be0&gt; not in the window | | | &lt;MFConversationViewController 0x12681e200&gt;, state: disappeared, view: &lt;UIView 0x125ea9620&gt; not in the window` 找到控制器MailboxContentViewController测试： 1cy# [#0x126048c00 setTitle:@&quot;vvusu&quot;] 控制Title已修改，已找到实现代理控制器。 MailboxContentViewController中定位“刷新完成”的响应函数看看MailboxContentViewController实现了哪些protocol，其中找到可疑的响应函数，如下： 1@interface MailboxContentViewController : UIViewController &lt;MFAddressBookClient, MailboxContentSelectionModelDataSource, MFMailboxFilterPickerViewControllerDelegate, MessageMiniMallObserver, MFReclaimable, MFSearchControllerDelegate, MFSwipableTableViewDelegate, UIPopoverPresentationControllerDelegate, UIViewControllerPreviewingDelegate, UIViewControllerPreviewingDelegate_Private, MFDisclosureSelectionTableViewDelegate, MFConversationViewControllerDelegate, MFMoveToPredictionTriageInteractionDelegate, MFTransferStackControllerDelegate, MFExpandedMessageCollectionStrategyDelegate, UITableViewDelegate, UITableViewDataSource, AutoFetchControllerDataSource, MFKeyCommandReacting&gt; 查找protocol跟“刷新数据源”有关系的方法。 查看相关代理方法可能有关系的 12345MailboxContentSelectionModelDataSourceMessageMiniMallObserverMFMailboxTableViewDelegateTransferMailboxPickerDelegateAutoFetchControllerDataSource MailboxContentSelectionModelDataSource-Protocol.h1234567891011121314151617181920#import &quot;NSObject-Protocol.h&quot;@class MFMessageInfo, MailboxContentSelectionModel, NSIndexPath, NSSet;@protocol MiniMallSource;@protocol MailboxContentSelectionModelDataSource &lt;NSObject&gt;- (_Bool)selectionModel:(MailboxContentSelectionModel *)arg1 deleteMovesToTrashForTableIndexPath:(NSIndexPath *)arg2;- (void)selectionModel:(MailboxContentSelectionModel *)arg1 getConversationStateAtTableIndexPath:(NSIndexPath *)arg2 hasUnread:(_Bool *)arg3 hasUnflagged:(_Bool *)arg4;- (void)selectionModel:(MailboxContentSelectionModel *)arg1 getSourceStateHasUnread:(_Bool *)arg2 hasUnflagged:(_Bool *)arg3;- (NSIndexPath *)selectionModel:(MailboxContentSelectionModel *)arg1 indexPathForMessageInfo:(MFMessageInfo *)arg2;- (NSSet *)selectionModel:(MailboxContentSelectionModel *)arg1 messageInfosAtTableIndexPath:(NSIndexPath *)arg2;- (NSSet *)selectionModel:(MailboxContentSelectionModel *)arg1 messagesForMessageInfos:(NSSet *)arg2;- (_Bool)selectionModel:(MailboxContentSelectionModel *)arg1 shouldArchiveByDefaultForTableIndexPath:(NSIndexPath *)arg2;- (id &lt;MiniMallSource&gt;)selectionModel:(MailboxContentSelectionModel *)arg1 sourceForMessageInfo:(MFMessageInfo *)arg2;- (_Bool)selectionModel:(MailboxContentSelectionModel *)arg1 supportsArchivingForTableIndexPath:(NSIndexPath *)arg2;- (NSSet *)sourcesForSelectionModel:(MailboxContentSelectionModel *)arg1;@optional- (NSSet *)selectionModel:(MailboxContentSelectionModel *)arg1 sourcesForMessageInfos:(NSSet *)arg2;@end MessageMiniMallObserver-Protocol.h123456789101112@class NSNotification;@protocol MessageMiniMallObserver- (void)miniMallCurrentMessageRemoved:(NSNotification *)arg1;- (void)miniMallDidFinishSearch:(NSNotification *)arg1;- (void)miniMallDidLoadMessages:(NSNotification *)arg1;- (void)miniMallFinishedFetch:(NSNotification *)arg1;- (void)miniMallGrowingMailboxesChanged:(NSNotification *)arg1;- (void)miniMallMessageCountDidChange:(NSNotification *)arg1;- (void)miniMallMessageCountWillChange:(NSNotification *)arg1;- (void)miniMallMessagesAtIndexPathsChanged:(NSNotification *)arg1;- (void)miniMallStartFetch:(NSNotification *)arg1;@end 这个类中函数名含有完成时态动词，同时从“LoadMessages”、“FinishedFetch”、“MessageCountChanged”等函数的名字上来看，它可能会在刷新完成的前后得到调用。接下来用LLDB在这3个函数的开头部分下断点，然后下拉刷新收件箱，看看它们的调用情况。首先用LLDB附加MobileMail，查看其ASLR偏移0x00000000000d0000 1234567891011121314151617(lldb) process connect connect://192.168.11.66:1234Process 11804 stopped* thread #1: tid = 0xb3da2, 0x00000001882ed188 libsystem_kernel.dylib`mach_msg_trap + 8, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP frame #0: 0x00000001882ed188 libsystem_kernel.dylib`mach_msg_trap + 8libsystem_kernel.dylib`mach_msg_trap:-&gt; 0x1882ed188 &lt;+8&gt;: retlibsystem_kernel.dylib`mach_msg_overwrite_trap: 0x1882ed18c &lt;+0&gt;: movn x16, #0x1f 0x1882ed190 &lt;+4&gt;: svc #0x80 0x1882ed194 &lt;+8&gt;: ret(lldb)image list -o -f[ 0] 0x00000000000d0000 /Applications/MobileMail.app/MobileMail(0x00000001000d0000)[ 1] 0x0000000100430000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x0000000100430000)[ 2] 0x0000000007cc8000 /Users/vvusu/Library/Developer/Xcode/iOS DeviceSupport/10.2 (14C92)/Symbols/System/Library/PrivateFrameworks/UserManagement.framework/UserManagement[ 3] 0x0000000007cc8000 /Users/vvusu/Library/Developer/Xcode/iOS DeviceSupport/10.2 (14C92)/Symbols/System/Library/Frameworks/OpenGLES.framework/OpenGLES... 把MobileMail拖进IDA,查看[MailboxContentViewController megaMallDidLoadMessages:] 12345 -[MailboxContentViewController miniMallDidLoadMessages:]:000000010000a910 stp x20, x19, [sp, #-0x20]! ; Objective C Implementation defined at 0x10029b208 (instance method), DATA XREF=0x10029b208000000010000a914 stp x29, x30, [sp, #0x10]000000010000a918 add x29, sp, #0x10000000010000a91c mov x19, x0 [MailboxContentViewController miniMallFinishedFetch:] 12345 -[MailboxContentViewController miniMallFinishedFetch:]:000000010003c57c stp x29, x30, [sp, #-0x10]! ; Objective C Implementation defined at 0x10029b1a8 (instance method), DATA XREF=0x10029b1a8000000010003c580 mov x29, sp000000010003c584 sub sp, sp, #0x30000000010003c588 adrp x8, #0x100270000 [MailboxContentViewController miniMallMessageCountDidChange:] 1234 -[MailboxContentViewController miniMallMessageCountDidChange:]:000000010003c864 stp x22, x21, [sp, #-0x30]! ; Objective C Implementation defined at 0x10029b238 (instance method), DATA XREF=0x10029b238000000010003c868 stp x20, x19, [sp, #0x10]000000010003c86c stp x29, x30, [sp, #0x20] 用LLDB在这些地址上下断点，然后下拉刷新，触发断点如下： 12345678910111213141516171819202122232425262728(lldb) br s -a &apos;0x00000000000d0000 + 0x000000010000a910&apos;Breakpoint 1: where = MobileMail`_mh_execute_header + 25960, address = 0x00000001000da910(lldb) br s -a &apos;0x00000000000d0000 + 0x000000010003c57c&apos;Breakpoint 2: where = MobileMail`_mh_execute_header + 229844, address = 0x000000010010c57c(lldb) br s -a &apos;0x00000000000d0000 + 0x000000010003c864&apos;Breakpoint 3: where = MobileMail`_mh_execute_header + 230588, address = 0x000000010010c864(lldb) cProcess 11804 resumingProcess 11804 stopped* thread #1: tid = 0xb3da2, 0x000000010010c864 MobileMail`_mh_execute_header + 247908, queue = &apos;MessageMiniMall.0x1741841d0&apos;, stop reason = breakpoint 3.1 frame #0: 0x000000010010c864 MobileMail`_mh_execute_header + 247908MobileMail`_mh_execute_header:-&gt; 0x10010c864 &lt;+247908&gt;: stp x22, x21, [sp, #-48]! 0x10010c868 &lt;+247912&gt;: stp x20, x19, [sp, #16] 0x10010c86c &lt;+247916&gt;: stp x29, x30, [sp, #32] 0x10010c870 &lt;+247920&gt;: add x29, sp, #32 ; =32(lldb) cProcess 11804 resumingProcess 11804 stopped* thread #34: tid = 0xb45b7, 0x000000010010c57c MobileMail`_mh_execute_header + 247164, stop reason = breakpoint 2.1 frame #0: 0x000000010010c57c MobileMail`_mh_execute_header + 247164MobileMail`_mh_execute_header:-&gt; 0x10010c57c &lt;+247164&gt;: stp x29, x30, [sp, #-16]! 0x10010c580 &lt;+247168&gt;: mov x29, sp 0x10010c584 &lt;+247172&gt;: sub sp, sp, #48 ; =48 0x10010c588 &lt;+247176&gt;: adrp x8, 564(lldb)Process 11804 resuming miniMallFinishedFetch方法和miniMallMessageCountDidChange方法都会调用。接下来的任务是寻找拿到所有邮件的方法。 从MessageMiniMall中拿到所有邮件“协议方法被调用，一般是因为方法名中提到的那个事件发生了；而那件事发生的对象，一般是协议方法的参数”吗？删掉前2个断点，保留第3个，也就是miniMallMessageCountDidChange:上的断点，看看它的参数是什么，如下： 1234(lldb) po $x19NSConcreteNotification 0x17425e570 &#123;name = MiniMallMessageCountDidChange; object = &lt;MessageMiniMall: 0x1741841d0&gt;; userInfo = MMRowsChangedContext removed:(none), inserted:(none), updated:&#123;( &lt;NSIndexPath: 0xc000000000000016&gt; &#123;length = 2, path = 0 - 0&#125;)&#125;, relocated:(none), destination:(none), mergedConversations:(none)&#125; 参数是一个NSConcreteNotification对象。查看其头文件，可知它继承自NSNotification。它的name是miniMallMessageCountDidChange,object是一个MessageMiniMall对象. 查看MessageMiniMall.h，看看它的内容，如下： 1234567891011121314151617181920@class MFActivityMonitor, MFMailMessage, MFMessageInfoOrderedSet, MessageSelectionStrategy, NSCache, NSDictionary, NSMutableSet, NSString, SourceSearchContext;@protocol OS_dispatch_queue;@interface MessageMiniMall : NSObject &lt;MFDiagnosticsGenerator, MessageSelectionDataSource, MiniMallSourceBulkOperationsDelegate&gt;...- (id)copyAllMessages;- (unsigned long long)localMessageCount;- (void)markAllMessagesAsDeletedOrArchived:(unsigned long long)arg1;- (void)markAllMessagesAsFlagged;- (void)markAllMessagesAsNotFlagged;- (void)markAllMessagesAsNotViewed;- (void)markAllMessagesAsViewed;- (void)markMessages:(id)arg1 asDeletedOrArchived:(unsigned long long)arg2;- (void)markMessagesAsFlagged:(id)arg1;- (void)markMessagesAsJunk:(id)arg1;- (void)markMessagesAsNotFlagged:(id)arg1;- (void)markMessagesAsNotJunk:(id)arg1;- (void)markMessagesAsNotViewed:(id)arg1;- (void)markMessagesAsViewed:(id)arg1;... 发现方法“复制所有邮件、当前邮件、读取早期邮件、本地邮件计数、邮件计数、标为已读……“MessageMiniMall应该就是一个管理所有邮件对象的管理者。尝试着通过- (id)copyAllMessages;拿到所有的邮件，在LLDB里试一下，如下： 12345678910111213141516(lldb) po [0x174192620 copyAllMessages]&#123;( &lt;MFLibraryMessage 0x143de28a0: library id 295, remote id 1333714967, conversation id 524108692882186053, 2017-02-09 01:29:08 +0000, subject hash: &lt;9cdcab9e 2f66ad52 f867dac2 ee7e3cf7 8e94d811&gt;&gt;, &lt;MFLibraryMessage 0x143d8a1a0: library id 301, remote id 1333714974, conversation id -5996875561049400297, 2017-02-23 09:52:07 +0000, subject hash: &lt;957a6ec0 0d226e39 27721f65 82c7bdd2 ed321b71&gt;&gt;, &lt;MFLibraryMessage 0x143d65730: library id 314, remote id 1333714977, conversation id -5225043346560767357, 2017-02-24 05:56:47 +0000, subject hash: &lt;MFLibraryMessage 0x143ebbfe0: library id 315, remote id 1333714978, conversation id -856873890138472988, 2017-02-24 06:59:43 +0000, subject hash: &lt;da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709&gt;&gt;, &lt;MFLibraryMessage 0x143ddbf30: library id 313, remote id 1333714976, conversation id -5225043346560767357, 2017-02-24 05:50:42 +0000, subject hash: &lt;da39a3ee 5e6b4b0d 3255bfef 95601890 afd80709&gt;&gt;, &lt;MFLibraryMessage 0x143e63420: library id 300, remote id 1333714973, conversation id -3478309731197128726, 2017-02-21 04:00:11 +0000, subject hash: &lt;5fcacdee c1b93ceb f297ec10 5ae0d003 fa94e8e5&gt;&gt;)&#125;(lldb) p (int)[[$x19 object] localMessageCount](int) $4 = 12(lldb) p (int)[[[$x19 object] copyAllMessages] count](int) $5 = 12(lldb) p (int)[[$x19 object] messageCount](int) $6 = 11(lldb) po [[[$x19 object] copyAllMessages] class]__NSSetM copyAllMessages返回了一个NSSet，其中含有12个MFLibraryMessage对象，MFLibraryMessage对象中含有邮件摘要信息，且NSSet中对象的个数与localMessageCount的值相同。这个结果很好理解：为了节省带宽流量和本地空间，iOS没有必要一次性下 载邮件服务器上的所有邮件，因此会先存储个百十来封，用户如果要看更多的邮件，再去服务器获取（即 loadOlderMessages）。因此，copyAllMessages就是拿到所有邮件的方法。同时[MessageMiniMall markMessagesAsViewed:]函数，如果不出意外，它就是把邮件标记为已读的方法，而参数则很有可能是一个含有MFLibraryMessage对象的NSArray或NSSet。 从MFLibraryMessage中提取发件人地址，用MessageMiniMall标记已读一封邮件就是一个MFLibraryMessage对象，它的description里显示的正是邮件摘要。在MessageMiniMall的头文件中是找不到它的身影的，想必你也能猜到大致原因MFLibraryMessage来自一个外部dylib。MFLibraryMessage.h的内容： 1234567891011121314151617181920@interface MFLibraryMessage : MFMailMessage &#123; unsigned long long _conversationFlags; unsigned int _libraryID; unsigned int _mailboxID; NSString * _messageID; NSMutableDictionary * _metadata; NSMutableSet * _metadataChangedKeys; MFLock * _metadataLock; unsigned int _originalMailboxID; NSString * _remoteID; unsigned long long _size; unsigned int _uid; unsigned long long _uniqueRemoteId;&#125;+ (id)messageWithLibraryID:(unsigned int)arg1;- (id)_attachmentStorageLocation;- (void)_forceLoadOfMessageSummaryFromProtectedStore;- (void)_initializeMetadata;- (void)_updateUID;- @end MFMessageInfo中含有已读信息，但不含有邮件摘要信息，说明分析仍不够严密。再回过头仔细观察 MFLibraryMessage.h，发现它继承自MFMailMessage，从名字上看MailMessage用来代表 邮件显然比LibraryMessage更贴切。打开MFMailMessage.h，看看它的内容： 123456789101112131415161718192021222324252627282930@interface MFMessage : NSObject &lt;NSCopying&gt; &#123; NSArray * _bcc; NSString * _cachedMessageIDHeader; unsigned int _calculatedAttachmentInfo; NSArray * _cc; NSString * _contentType; long long _conversationID; unsigned int _dateReceivedInterval; unsigned int _dateSentInterval; NSString * _externalID; unsigned long long _generationNumber; long long _listIDHash; long long _messageIDHeaderHash; NSURL * _messageURL; unsigned short _numberOfAttachments; MFMimePart * _parentPart; unsigned int _preferredEncoding; NSArray * _sender; NSString * _senderAddressComment; MFMessageStore * _store; NSString * _subject; NSString * _summary; NSArray * _to;&#125;@property (nonatomic, retain) MFMimePart *parentPart;+ (Class)dataMessageStoreToUse;+ (id)messageWithRFC822Data:(id)arg1;+ (id)messageWithRFC822Data:(id)arg1 withParentPart:(id)arg2;+ (void)setMessageClassForStore:(id)arg1; summary、subject、sender、cc、bcc等邮件常用词汇出现在我们面前，但除了subject， MFMailMessage.h中只出现了setter，而不见getter。还 记得刚才我们的注意力是怎么从MFLibraryMessage.h 转移到MFMailMessage.h上的吗？想必你一定也注意 到了MFMailMessage的父类MFMessage。在查看它的 头文件前，先用LLDB看看[MFMailMessage subject]的 返回，验证一下到目前为止的分析，如下： 1234567891011121314151617181920212223242526272829(lldb) po [[[[$x19 object] copyAllMessages] anyObject] subject]送您的20000金币已到账，速领兑大奖！(lldb) po [[[[$x19 object] copyAllMessages] anyObject] firstSender]&quot;疯狂炸金花&quot; &lt;crazy3@service.netease.com&gt;(lldb) po [[[[$x19 object] copyAllMessages] anyObject] sendersIfCached]&lt;__NSSingleObjectArrayI 0x170208ab0&gt;(&quot;疯狂炸金花&quot; &lt;crazy3@service.netease.com&gt;)(lldb) po [[[[$x19 object] copyAllMessages] anyObject] senders]&lt;__NSSingleObjectArrayI 0x170208ab0&gt;(&quot;疯狂炸金花&quot; &lt;crazy3@service.netease.com&gt;)(lldb) po [[[[$x19 object] copyAllMessages] anyObject] to]&lt;__NSSingleObjectArrayI 0x170208aa0&gt;(wedxzl@163.com)(lldb) po [[[[$x19 object] copyAllMessages] anyObject] dateSent]2017-02-09 01:28:56 +0000(lldb) po [[[[$x19 object] copyAllMessages] anyObject] subject]送您的20000金币已到账，速领兑大奖！(lldb) po [[[[$x19 object] copyAllMessages] anyObject] messageBody]&lt;MFMimeBody: 0x1704319a0&gt; firstSender返回了一个发件人，而sendersIfCached 和senders都返回了一个NSArray，说明默认情况下， 在iOS中一封邮件是有可能存在多个发件人的。尽管多个发件人的情况在现实生活中不常见，但为了避免遗漏，这里仍采用senders函数来提取一封邮件中所有可能的发件人地址。最后的任务就 是把邮件标记为已读。 [MessageMiniMall markMessagesAsViewed:]吗？它是 不是把邮件标为已读的方法呢？在这个方法上下一个 断点，看看在把一封邮件标记为已读时，它会不会得 到调用。先在IDA里定位到[MessageMiniMall markMessagesAsViewed:]，看看它的基地址： 12345 -[MessageMiniMall markMessagesAsViewed:]:000000010006e710 stp x22, x21, [sp, #-0x30]! ; Objective C Implementation defined at 0x1002a6d10 (instance method), DATA XREF=0x1002a6d10000000010006e714 stp x20, x19, [sp, #0x10]000000010006e718 stp x29, x30, [sp, #0x20]000000010006e71c add x29, sp, #0x20 测试下断点： 123456789101112(lldb) br s -a &apos;0x00000000000c8000+0x000000010006e710&apos;Breakpoint 5: where = MobileMail`_mh_execute_header + 435048, address = 0x0000000100136710(lldb) cProcess 11873 resuming* thread #1: tid = 0xb5cf8, 0x0000000100136710 MobileMail`_mh_execute_header + 452368, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 5.1 frame #0: 0x0000000100136710 MobileMail`_mh_execute_header + 452368MobileMail`_mh_execute_header:-&gt; 0x100136710 &lt;+452368&gt;: stp x22, x21, [sp, #-48]! 0x100136714 &lt;+452372&gt;: stp x20, x19, [sp, #16] 0x100136718 &lt;+452376&gt;: stp x29, x30, [sp, #32] 0x10013671c &lt;+452380&gt;: add x29, sp, #32 ; =32(lldb) [MessageMiniMall markMessagesAsViewed:]就是把邮件标为已读的方法，且其参数是一个由 MFLibraryMessage对象组成的NSSet。至此，我们成功地在界面上添加了白名单按钮，捕获到了“刷新完成”事件，拿到了所有邮件，提取了其中的发件人地址，并能将它们标为已读。 1.在界面上寻找添加白名单按钮的地方和方法。2.在protocol里寻找“刷新完成”的响应函数。3.从MessageMiniMall中拿到所有邮件。4.从MFLibraryMessage中提取发件人地址。5.用MessageMiniMall将邮件标记为已读。 编写tweak用Theos新建tweak工程“AutoMailMarker”12345678910111213141516171819202122➜ AutoMailMarker $THEOS/bin/nic.plNIC 2.0 - New Instance Creator------------------------------ [1.] iphone/activator_event [2.] iphone/application_modern [3.] iphone/cydget [4.] iphone/flipswitch_switch [5.] iphone/framework [6.] iphone/ios7_notification_center_widget [7.] iphone/library [8.] iphone/notification_center_widget [9.] iphone/preference_bundle_modern [10.] iphone/tool [11.] iphone/tweak [12.] iphone/xpc_serviceChoose a Template (required): 11Project Name (required): AutoMailMarkerPackage Name [com.yourcompany.automailmarker]: com.vvusu.automailmarker [ Author/Maintainer Name [vvusu]:[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.mobilemail[iphone/tweak] List of applications to terminate upon installation (space-separated, &apos;-&apos; for none) [SpringBoard]: MobileMailInstantiating iphone/tweak in automailmarker/...Done. 构造AutoMailMarker.h构造它的目的仅仅是通过编译，避免出现任何报错信息和警告。 123456789101112131415161718192021#import &quot;AutoMailMarker.h&quot;@interface MailboxPickerController : UITableViewController@end@interface NSConcreteNotification : NSNotification@end@interface MessageMiniMall : NSObject- (NSSet *)copyAllMessages;- (void)markMessagesAsViewed:(NSSet *)arg1;@end@interface MFMessageInfo : NSObject@property (nonatomic) BOOL read;@end@interface MFLibraryMessage : NSObject- (NSArray *)senders;- (MFMessageInfo *)copyMessageInfo;@end 编辑Tweak.xm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import &quot;AutoMailMarker.h&quot;%hook MailboxPickerController%new- (void)autoMailMarkerWhitelist &#123; UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;Whitelist&quot; message:@&quot;Please input an email address&quot; preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *okAction = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * action) &#123; UITextField *whitelistField = alertController.textFields.firstObject; if ([whitelistField.text length] != 0) &#123; [[NSUserDefaults standardUserDefaults] setObject:whitelistField.text forKey:@&quot;email.whitelist&quot;]; &#125; &#125;]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;Cancel&quot; style:UIAlertActionStyleCancel handler:nil]; [alertController addAction:okAction]; [alertController addAction:cancelAction]; [alertController addTextFieldWithConfigurationHandler:^(UITextField *textField) &#123; textField.text = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;email.whitelist&quot;]; textField.placeholder = textField.text; &#125;]; [self presentViewController:alertController animated:YES completion:nil];&#125;- (void)viewDidLayoutSubviews &#123; %orig; self.navigationItem.leftBarButtonItem = [[[UIBarButtonItem alloc] initWithTitle: @&quot;Whitelist&quot; style:UIBarButtonItemStylePlain target:self action:@selector(autoMailMarkerWhitelist)]autorelease];&#125;%end%hook MailboxContentViewController- (void)miniMallMessageCountDidChange:(NSConcreteNotification *)arg1 &#123; %orig; NSMutableSet *targetMessages = [NSMutableSet set]; NSString *whitelist = [NSString stringWithFormat:@&quot;&lt;%@&gt;&quot;,[[NSUserDefaults standardUserDefaults] objectForKey: @&quot;email.whitelist&quot;]]; MessageMiniMall *managerMail = [arg1 object]; NSSet *messages = [managerMail copyAllMessages]; for (MFLibraryMessage *message in messages) &#123; MFMessageInfo *messageInfo = [message copyMessageInfo]; for (NSString *sender in [message senders]) &#123; if (!messageInfo.read &amp;&amp; [sender rangeOfString:whitelist].location == NSNotFound) &#123; [targetMessages addObject:message]; [messageInfo release]; &#125; &#125; [messages release]; [managerMail markMessagesAsViewed:targetMessages]; &#125;&#125;%end 编辑Makefile及controlMakefile文件 1234567891011THEOS_DEVICE_IP = 192.168.11.66ARCHS = armv7 arm64TARGET = iphone:latest:8.0include $(THEOS)/makefiles/common.mkTWEAK_NAME = AutoMailMarkerAutoMailMarker_FILES = Tweak.xminclude $(THEOS_MAKE_PATH)/tweak.mkafter-install:: install.exec &quot;killall -9 MobileMail&quot; control文件 12345678910Package: com.vvusu.automailmarkerName: AutoMailMarkerDepends: mobilesubstrate, firmware (&gt;= 8.0)Version: 1.0Architecture: iphoneos-armDescription: Mark non-whitelist emails as read!Maintainer: vvusuAuthor: vvusuSection: TweaksHomepage: http://blog.vvusu.com 安装与测试打开邮件程序，添加白名单，测试给自己发一封邮件，点击Inbox查看效果。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 越狱开发实战1—Notes 显示字数]]></title>
    <url>%2Fblog%2FiOS%20%E8%B6%8A%E7%8B%B1%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%981_Characount%20for%20Notes%2F</url>
    <content type="text"><![CDATA[功能描述：Apple Notes iOS10.2Notes编辑时在导航栏动态显示当前文本的字数。 CharacountForNotesclass-dump出MobileNotes的头文件Notes不是从AppStore下载的，没有加壳，所以可以直接使用class-dump导出头文件 12➜ ~ class-dump -S -s -H /Users/vvusu/Downloads/Reverse_iOS/REDemo/CountForNotes/MobileNotes -o /Users/vvusu/Downloads/Reverse_iOS/REDemo/CountForNotes/MobileNotesHeard2017-02-21 18:37:45.748 class-dump[71600:2785396] Warning: Parsing instance variable type failed, _cancelRenderingCount 用Cycript找到阅览界面及其controller查找MobileNotes进程 12345678910WSCN-6SP:~ root# ps -e |grep Applications 8960 ?? 0:00.45 /Applications/Maps.app/PlugIns/MapsWidget.appex/MapsWidget 8990 ?? 0:00.95 /Applications/BarrelSettings.app/BarrelSettings 8992 ?? 0:06.02 /Applications/AppStore.app/AppStore 9002 ?? 0:06.20 /Applications/Cydia.app/Cydia 9061 ?? 0:00.22 /Applications/MobileMail.app/PlugIns/MailVIPWidget.appex/MailVIPWidget 9064 ?? 0:02.29 /Applications/MobileMail.app/MobileMail 9078 ?? 0:02.47 /Applications/Preferences.app/Preferences 9185 ?? 0:00.93 /Applications/MobileNotes.app/MobileNotes ... 进入cycript 调试 1WSCN-6SP:~ root# cycript -p MobileNotes 打印控制器列表 12345678910cy# [[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()`&lt;ICSplitViewController 0x1005667a0&gt;, state: appeared, view: &lt;UILayoutContainerView 0x10074ac80&gt; | &lt;UIMultiColumnViewController 0x100567050&gt;, state: appeared, view: &lt;UIView 0x100574f00&gt; | | &lt;UINavigationController 0x10083f800&gt;, state: appeared, view: &lt;UILayoutContainerView 0x100753ba0&gt; | | | &lt;ICFolderListViewController 0x100732fc0&gt;, state: disappeared, view: &lt;NotesBackgroundView 0x100757370&gt; not in the window | | | &lt;ICModernNotesListViewController 0x100846800&gt;, state: disappeared, view: &lt;NotesBackgroundView 0x100728750&gt; not in the window | | | &lt;UINavigationController 0x101036600&gt;, state: appeared, view: &lt;UILayoutContainerView 0x10072cc30&gt; | | | | &lt;ICNoteEditorViewController 0x10101b400&gt;, state: appeared, view: &lt;NotesBackgroundView 0x1005a0e70&gt; | | | | | &lt;ICTextViewController 0x10059bc10&gt;, state: appeared, view: &lt;ICTextView 0x1008e3400&gt; | | &lt;UINavigationController 0x100850000&gt;, state: disappeared, view: (view not loaded)` 查看到ICTextViewController为最上层控制器，为笔记展示控制器。ICNoteEditorViewController为导航栏控制器。 测试修改一下NavigationController的title，发现改变了title显示,已经找到目标控制器。 1cy# [#0x10101b400 setTitle:@&quot;nihao&quot;] 从ICNoteEditorViewController找到当前TextView对象到ICNoteEditorViewController.h里看看它的 定义123456789101112@interface ICNoteEditorViewController : ICScrollViewDelegateViewController &lt;ICStyleSelectorDelegate, UIImagePickerControllerDelegate, UINavigationControllerDelegate, NSUserActivityDelegate, UIPopoverPresentationControllerDelegate, UIGestureRecognizerDelegate, UIViewControllerPreviewingDelegate_Private, ICAudioBarViewControllerDelegate, ICNoteEditorInputAccessoryViewDelegate, UICloudSharingControllerDelegate, ICNoteDelegate, UITextViewDelegate&gt;@property(retain, nonatomic) ICNote *note; // @synthesize note=_note;@property(readonly, nonatomic) ICTextView *textView;@property(retain, nonatomic) ICTextController *textController; // @synthesize textController=_textController;@property(readonly, nonatomic) double textViewBottomInsetThatWeWant;- (void)textViewDidBeginEditing:(id)arg1;- (void)textViewDidChange:(id)arg1;- (void)textViewDidChangeSelection:(id)arg1;- (void)textViewDidEndEditing:(id)arg1;- (id)textViewInputAccessoryView;... 查看ICNoteEditorViewController控制器中有实现编辑文字的代理，利用LLDB+Hopper 动态调试设置断点，点击编辑笔记时观察断点是否触发。 开启Debugserver123456WSCN-6SP:~ root# debugserver *:1234 -a &quot;MobileNotes&quot;debugserver-@(#)PROGRAM:debugserver PROJECT:debugserver-360.0.26.1 for arm64.Attaching to process MobileNotes...Listening to port 1234 for a connection from *...Waiting for debugger instructions for process 0. LLDB连接Debugserver123456789101112➜ ~ lldb(lldb) process connect connect://192.168.11.173:1234Process 8910 stopped* thread #1: tid = 0x7ecdf, 0x00000001882ed188 libsystem_kernel.dylib`mach_msg_trap + 8, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP frame #0: 0x00000001882ed188 libsystem_kernel.dylib`mach_msg_trap + 8libsystem_kernel.dylib`mach_msg_trap:-&gt; 0x1882ed188 &lt;+8&gt;: retlibsystem_kernel.dylib`mach_msg_overwrite_trap: 0x1882ed18c &lt;+0&gt;: movn x16, #0x1f 0x1882ed190 &lt;+4&gt;: svc #0x80 0x1882ed194 &lt;+8&gt;: ret(lldb) MobileNotes ASLR偏移12(lldb) image list -o -f [ 0] 0x00000000000e8000 /Applications/MobileNotes.app/MobileNotes(0x00000001000e8000) Hopper分析把MobileNotes二进制文件拖入Hopper分析，在左边搜索栏中搜索textViewDidChange方法，找到-[ICNoteEditorViewController textViewDidChange:]:方法其基地址为0000000100036948偏移后地址：0000000100036948+00000000000e8000 = 000000010011E948 1234567 -[ICNoteEditorViewController textViewDidChange:]:0000000100036948 stp x28, x27, [sp, #-0x60]! ; Objective C Implementation defined at 0x1002bca68 (instance method), DATA XREF=0x1002bca68000000010003694c stp x26, x25, [sp, #0x10]0000000100036950 stp x24, x23, [sp, #0x20]0000000100036954 stp x22, x21, [sp, #0x30]0000000100036958 stp x20, x19, [sp, #0x40]000000010003695c stp x29, x30, [sp, #0x50] 设置断点123456789101112(lldb) br s -a 10011E948Breakpoint 1: where = MobileNotes`_mh_execute_header + 201188, address = 0x000000010011e948(lldb) cProcess 7767 resumingProcess 7767 stopped* thread #1: tid = 0x77054, 0x000000010011e948 MobileNotes`_mh_execute_header + 223560, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1 frame #0: 0x000000010011e948 MobileNotes`_mh_execute_header + 223560MobileNotes`_mh_execute_header:-&gt; 0x10011e948 &lt;+223560&gt;: stp x28, x27, [sp, #-96]! 0x10011e94c &lt;+223564&gt;: stp x26, x25, [sp, #16] 0x10011e950 &lt;+223568&gt;: stp x24, x23, [sp, #32] 0x10011e954 &lt;+223572&gt;: stp x22, x21, [sp, #48] 当编辑笔记时断点多次触发，这样可以在控制器实现代理时动态获取文本，并能获取文本的个数。 创建Tweak创建CharacountForNotes Tweak插件1234567891011121314151617181920212223➜ CharacountForNotes $THEOS/bin/nic.plNIC 2.0 - New Instance Creator------------------------------ [1.] iphone/activator_event [2.] iphone/application_modern [3.] iphone/cydget [4.] iphone/flipswitch_switch [5.] iphone/framework [6.] iphone/ios7_notification_center_widget [7.] iphone/library [8.] iphone/notification_center_widget [9.] iphone/preference_bundle_modern [10.] iphone/tool [11.] iphone/tweak [12.] iphone/xpc_serviceChoose a Template (required): 11Project Name (required): CharacountForNotesPackage Name [com.yourcompany.characountfornotes]:Author/Maintainer Name [vvusu]:com.vvusu.characountfornotes[iphone/tweak] MobileSubstrate Bundle filter [com.apple.springboard]: com.apple.mobilenotes[iphone/tweak] List of applications to terminate upon installation (space-separated, &apos;-&apos; for none) [SpringBoard]:Instantiating iphone/tweak in characountfornotes/...Done. control文件内容12345678910Package: com.vvusu.characountfornotesName: CharacountForNotesDepends: mobilesubstrate, firmware (&gt;= 9.0)Version: 0.0.1Architecture: iphoneos-armDescription: Add a character count to NotesMaintainer: vvusuAuthor: vvusuSection: TweaksHomepage: http://blog.vvusu.com Makefile文件内容123456789101112THEOS_DEVICE_IP = 192.168.11.66ARCHS = armv7 arm64TARGET = iphone:latest:9.0 include $(THEOS)/makefiles/common.mkTWEAK_NAME = CharacountForNotesCharacountForNotes_FILES = Tweak.xminclude $(THEOS_MAKE_PATH)/tweak.mkafter-install:: install.exec &quot;killall -9 SpringBoard&quot; 创建CharacountForNotes.h123456789#import &quot;CharacountForNotes.h&quot;@interface ICTextView : UIView@property (copy, nonatomic) NSString *text;@end@interface ICNoteEditorViewController : UIViewController@property (retain, nonatomic) ICTextView *textView;@end 这个头文件的所有内容均摘自类对应的头文件，构造它的目的仅仅是通过编译，避免任何报错和警告。 Tweak.xm文件内容12345678910111213141516171819202122#import &quot;CharacountForNotes.h&quot;%hook ICNoteEditorViewController// Initialze title- (void)viewWillAppear:(BOOL)arg1 &#123; %orig; NSString *content = self.textView.text; NSString *contentLength = [NSString stringWithFormat:@&quot;%lu&quot;, (unsigned long)[content length]]; self.title = contentLength;&#125;// Reset title- (void)viewDidDisappear:(BOOL)arg1 &#123; %orig; self.title = nil;&#125;// Update title- (void)textViewDidChange:(id)arg1 &#123; %orig; NSString *content = self.textView.text; NSString *contentLength = [NSString stringWithFormat:@&quot;%lu&quot;, (unsigned long)[content length]]; self.title = contentLength;&#125;%end 插件测试与安装1234567891011➜ characountfornotes make package install&gt; Making all for tweak CharacountForNotes…make[2]: Nothing to be done for `internal-library-compile&apos;.&gt; Making stage for tweak CharacountForNotes…dpkg-deb: building package &apos;com.vvusu.characountfornotes&apos; in &apos;./packages/com.vvusu.characountfornotes_0.0.1-13+debug_iphoneos-arm.deb&apos;.==&gt; Installing…(Reading database ... 4815 files and directories currently installed.)Preparing to unpack /tmp/_theos_install.deb ...Unpacking com.vvusu.characountfornotes (0.0.1-13+debug) over (0.0.1-12+debug) ...Setting up com.vvusu.characountfornotes (0.0.1-13+debug) ...install.exec &quot;killall -9 SpringBoard&quot; 打开手机Note，开始测试。实际测试iOS9~iOS10都可以正常使用。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 内存检测]]></title>
    <url>%2Fblog%2FiOS_%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[为了测试内存泄漏方便，封装了一个Framework。 相似框架MLeaksFinderPLeakSniffer 使用的时候直接导入Framework就可以，而且只在debug下开启, 真机会报错误，请删处Framework。 ###内存泄漏注意事项 1.Block里面self强引用 1234567_headerView.followClickBlock = ^() &#123; if (![self isLogin]) &#123; [[MRouter sharedRouter] handleURL:[NSURL URLWithString:@&quot;https://passport.wallstreetcn.com/login&quot;] userInfo:nil]; return; &#125; [weakSelf dealFollowClick];&#125;; block 里面的self用wself替换 1__weak typeof(self) wself = self; 2.自定义代理时强引用delegate 会造成内存泄漏； 如果父VC持有子VC，并设置子VC的delegate为self（也就是父VC），这样的结果就是子VC也间接持有了父VC，造成循环引用，在Pop子VC的时候不会调用delloc. 1@property (nonatomic, strong) id&lt;ProfileEditPickerViewDelegate&gt; delegate; 把strong修饰符改为weak 不用assign 3.OC和CF转化出现的内存警告用完添加CFRelease()释放对象 123CFStringRef cfString = CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,(CFStringRef)picDataString,NULL,CFSTR(&quot;:/?#[]@!$&amp;’()*+,;=&quot;),kCFStringEncodingUTF8);NSString *baseString = [NSString stringWithString:(NSString *)cfString];CFRelease(cfString); //不添加会泄漏 4.CATransition 动画removedOnCompletion属性 123456789101112CATransition *animation = [CATransition animation];animation.delegate = self;animation.duration = 0.3f;animation.timingFunction = UIViewAnimationCurveEaseInOut;animation.fillMode = kCAFillModeForwards;animation.type = kCATransitionPush;animation.subtype = kCATransitionFromLeft;animation.startProgress = 0.0;animation.endProgress = 1.0;animation.removedOnCompletion = NO; //有内存泄漏的风险[self.layer addAnimation:animation forKey:@&quot;animation&quot;];[self.textField resignFirstResponder]; 5.NSTimerNSTimer会造成循环引用，timer会强引用target即self，在加入runloop的操作中，又引用了timer，所以在timer被invalidate之前，self也就不会被释放。所以我们要注意，不仅仅是把timer当作实例变量的时候会造成循环引用，只要申请了timer，加入了runloop，并且target是self，虽然不是循环引用，但是self却没有释放的时机。如下方式申请的定时器，self已经无法释放了。 12NSTimer *timer = [NSTimer timerWithTimeInterval:5 target:self selector:@selector(commentAnimation) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; 解决这种问题有几个实现方式，大家可以根据具体场景去选择： 增加startTimer和stopTimer方法，在合适的时机去调用，比如可以在viewDidDisappear时stopTimer，或者由这个类的调用者去设置。每次任务结束时使用dispatch_after方法做延时操作。注意使用weakself，否则也会强引用self。 123456- (void)startAnimation &#123; __weak typeof(self) wself = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [weakSelf commentAnimation]; &#125;);&#125; 使用GCD的定时器，同样注意使用weakself。 1234567__weak typeof(self) wself = self;timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC, 1 * NSEC_PER_SEC);dispatch_source_set_event_handler(timer, ^&#123; [weakSelf commentAnimation];&#125;);dispatch_resume(timer); 6.NSNotification使用block的方式增加notification，引用了self，在删除notification之前，self不会被释放，与timer的场景类似，其实这段代码已经声明了weakself，但是调用_eventManger方法还是引起了循环引用。也就是说，即使我们没有调用self方法，_xxx也会造成循环引用。 12345678[[NSNotificationCenter defaultCenter] addObserverForName:kUserSubscribeNotification object:nil queue:nil usingBlock:^(NSNotification *note) &#123; if (note) &#123; Model *model=(Model *)note.object; if ([model.subId integerValue] == [weakSelf.subId integerValue]) &#123; [_eventManger playerSubsciption:NO]; &#125; &#125;&#125; 7.有一些图片很大用[UIImage imageNamed:@&quot;&quot;]加载的话回常驻内存，建议大的图片加载从本地文件加载[UIImage imageWithContentsOfFile:@&quot;&quot;] 8.performSelector延时调用导致的内存泄露 1[self performSelector:@selector(method1:) withObject:self.tableLayer afterDelay:3]; 有时切换场景时延时函数已经被调用但还没有执行，这时tableLayer的引用计数没有减少到0，也就导致了切换场景dealloc方法没有被调用，出现了内存泄露。所以解决办法就是取消那些还没有来得及执行的延时函数： 1[NSObject cancelPreviousPerformRequestsWithTarget:self]]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo GithubPages搭建个人博客]]></title>
    <url>%2Fblog%2FHexo_GithubPages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[##系统环境配置 要使用Hexo，需要在你的系统中支持Nodejs以及Git 安装Node.js 1brew install nodejs 安装Git 1brew install git ##安装Hexo 1234567891011$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看这里有必要提下Hexo常用的几个命令：hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 另外还有其他几个常用命令： 123456789101112$ hexo new &quot;postName&quot; #新建文章$ hexo new page &quot;pageName&quot; #新建页面常用简写$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy常用组合$ hexo d -g #生成部署$ hexo s -g #生成预览 现在我们打开http://localhost:4000/ 已经可以看到一篇内置的blog了。 目前我安装所用的本地环境如下：(可以通过hexo -v查看) 12345678910111213hexo: 3.2.0hexo-cli: 1.0.1os: Windows_NT 6.3.9600 win32 x64http_parser: 2.5.2node: 4.4.1v8: 4.5.103.35uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 46openssl: 1.0.2gHexo主题设置 这里以主题yilia为例进行说明。 安装主题 12$ hexo clean$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 启用主题修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。 更新主题 1234$ cd themes/yilia$ git pull$ hexo g # 生成$ hexo s # 启动本地web服务器 现在打开http://localhost:4000/ ，会看到我们已经应用了一个新的主题。 ##Github Pages设置 什么是Github PagesGitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过http://username.github.io 来访问你的个人主页。 这里特别提醒一下，需要注意的个人主页的网站内容是在master分支下的。 创建自己的Github Pages注册GitHub及使用Github Pages的过程已经有很多文章讲过，在此不再详述，可以参考： 在这里我创建了一个github repo叫做 sxsue.github.io. 创建完成之后，需要有一次提交(git commit)操作，然后就可以通过链接http://sxsue.github.io/ 访问了。（现在还没有内容，别着急） 部署Hexo到Github Pagessxsue这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过http://sxsue.github.io/访问了。不过很多教程文章对这个步骤语焉不详，这里着重说下。 首先需要明白所谓部署到github的原理。 之前步骤中在Github上创建的那个特别的repo（sxsue.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接http://sxsue.github.io来直接访问。Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。需要将hexo生成的静态网站，提交(git commit)到github上。明白了原理，怎么做自然就清晰了。 使用hexo deploy部署hexo deploy可以部署到很多平台，具体可以参考这个链接. 如果部署到github，需要在配置文件_config.xml中作如下修改： 123456789101112deploy: type: git repo: git@github.com:sxsue/sxsue.github.io.git branch: master然后在命令行中执行hexo d即可完成部署。注意需要提前安装一个扩展：$ npm install hexo-deployer-git --save ##使用git命令行部署不幸的是，上述命令虽然简单方便，但是偶尔会有莫名其妙的问题出现，因此，我们也可以追本溯源，使用git命令来完成部署的工作。 1234clone github repo$ cd /hexo/blog$ git clone https://github.com/sxsue/sxsue.github.io.git .deploy/sxsue.github.io 将我们之前创建的repo克隆到本地，新建一个目录叫做.deploy用于存放克隆的代码。 创建一个deploy脚本文件 1234567hexo generatecp -R public/* .deploy/sxsue.github.iocd .deploy/sxsue.github.iogit add .git commit -m “update”git push origin master简单解释一下，hexo generate生成public文件夹下的新内容，然后将其拷贝至sxsue.github.io的git目录下，然后使用git commit命令提交代码到sxsue.github.io这个repo的master branch上。 需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。 ##Hexo 主题配置 每个不同的主题会需要不同的配置，主题配置文件在主题目录下的_config.yml。以我们使用的yilia主题为例，其提供如下的配置项（theme\yilia_config.yml）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔 # SubNavsubnav: github: &quot;#&quot; weibo: &quot;#&quot; rss: &quot;#&quot; zhihu: &quot;#&quot; #douban: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml# Contentexcerpt_link: morefancybox: truemathjax: true# Miscellaneousgoogle_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar: &quot;&quot;#是否开启分享share: true#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true#是否开启云标签tagcloud: true#是否开启友情链接#不开启——#friends: false#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货… ##其他高级使用技巧 绑定独立域名购买域名在你的域名注册提供商那里配置DNS解析，获取GitHub的IP地址点击，进入source目录下，添加CNAME文件 12345$ cd source/$ touch CNAME$ vim CNAME # 输入你的域名$ git add CNAME$ git commit -m &quot;add CNAME&quot; ##使用图床使用七牛云存储自己在github上搭建的图床：http://sxsue.github.io/qiniuimgbed/ ，需要首先注册七牛账号使用。 ##添加插件添加sitemap和feed插件 12$ npm install hexo-generator-feed$ npm install hexo-generator-sitemap 修改_config.yml，增加以下内容 1234567891011121314# ExtensionsPlugins:- hexo-generator-feed- hexo-generator-sitemap#Feed Atomfeed: type: atom path: atom.xml limit: 20#sitemapsitemap: path: sitemap.xml 配完之后，就可以访问http://sxsue.github.io/atom.xml和http://sxsue.github.io/sitemap.xml，发现这两个文件已经成功生成了。 ##添加404公益页面GitHub Pages有提供制作404页面的指引：Custom 404 Pages。 直接在根目录下创建自己的404.html或者404.md就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。 推荐使用腾讯公益404。 ##添加about页面 1$ hexo new page &quot;about&quot; 之后在\source\about\index.md目录下会生成一个index.md文件，打开输入个人信息即可，如果想要添加版权信息，可以在文件末尾添加： 1234567891011121314&lt;div style=&quot;font-size:12px;border-bottom: #ddd 1px solid; BORDER-LEFT: #ddd 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #ddd 1px solid; BORDER-RIGHT: #ddd 1px solid&quot;&gt;&lt;div style=&quot;MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px&quot;&gt;&lt;IMG alt=&quot;&quot; src=&quot;https://avatars1.githubusercontent.com/u/168751?v=3&amp;s=140&quot; width=90 height=100&gt;&lt;/div&gt;&lt;div style=&quot;LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000&quot;&gt;本文链接：&lt;a href=&quot;&lt;%= post.link %&gt;&quot;&gt;&lt;%= post.title %&gt;&lt;/a&gt; &lt;br/&gt;作者： &lt;a href=&quot;http://sxsue.github.io/&quot;&gt;令狐葱&lt;/a&gt; &lt;br/&gt;出处： &lt;a href=&quot;http://sxsue.github.io/&quot;&gt;http://sxsue.github.io/&lt;/a&gt;&lt;br/&gt;本文基于&lt;a target=&quot;_blank&quot; title=&quot;Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)&quot; href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt; 知识共享署名-相同方式共享 4.0 &lt;/a&gt;国际许可协议发布，欢迎转载，演绎或用于商业目的，但是必须保留本文的署名 &lt;a href=&quot;http://sxsue.github.io/&quot;&gt;令狐葱&lt;/a&gt;及链接。&lt;/div&gt;&lt;/div&gt; ##添加Fork me on Github获取代码，选择你喜欢的代码添加到hexo/themes/yilia/layout/layout.ejs的末尾即可，注意要将代码里的you改成你的Github账号名。 ##添加支付宝捐赠按钮及二维码支付支付宝捐赠按钮在\hexo\themes\yilia\layout_widget目录下新建一个zhifubao.ejs文件，内容如下 1234567891011&lt;p class=&quot;asidetitle&quot;&gt;打赏他&lt;/p&gt;&lt;div&gt;&lt;form action=&quot;https://shenghuo.alipay.com/send/payment/fill.htm&quot; method=&quot;POST&quot; target=&quot;_blank&quot; accept-charset=&quot;GBK&quot;&gt; &lt;br/&gt; &lt;input name=&quot;optEmail&quot; type=&quot;hidden&quot; value=&quot;your 支付宝账号&quot; /&gt; &lt;input name=&quot;payAmount&quot; type=&quot;hidden&quot; value=&quot;默认捐赠金额(元)&quot; /&gt; &lt;input id=&quot;title&quot; name=&quot;title&quot; type=&quot;hidden&quot; value=&quot;博主，打赏你的！&quot; /&gt; &lt;input name=&quot;memo&quot; type=&quot;hidden&quot; value=&quot;你Y加油，继续写博客！&quot; /&gt; &lt;input name=&quot;pay&quot; type=&quot;image&quot; value=&quot;转账&quot; src=&quot;http://7xig3q.com1.z0.glb.clouddn.com/alipay-donate-website.png&quot; /&gt;&lt;/form&gt;&lt;/div&gt; 添加完该文件之后，要在/hexo/themes/yilia/_config.yml文件中启用，如下所示，添加zhifubao 1234567widgets:- category- tag- links- tagcloud- zhifubao- rss ##二维码捐赠首先需要到这里获取你的支付宝账户的二维码图片，支付宝提供了自定义功能，可以添加自定义文字。 我的二维码扫描捐赠添加在about页面，当然你也可以添加到其它页面，在\hexo\blog\source\about下有index.md，打开，在适当位置添加 12345&lt;center&gt;欢迎您捐赠本站，您的支持是我最大的动力！![][http://7xsxyo.com1.z0.glb.clouddn.com/2016/04/15/FoJ1F6Ht0CNaYuCdE2l52F-Fk9Vk202.png]&lt;/center&gt;&lt;br/&gt; &lt;center&gt;可以让图片居中显示，注意将图片链接地址换成你的即可。 ##添加百度站内搜索点击进入，点击其它工具-&gt;站内检索-&gt;现在使用-&gt;新建搜索引擎-&gt;查看代码，将代码里的id值复制，打开/hexo/themes/jacman/_config.xml，配置成如下即可。 1234baidu_search: ## http://zn.baidu.com/ enable: true id: &quot;1433674487421172828&quot; ## e.g. &quot;783281470518440642&quot; for your baidu search id site: http://zhannei.baidu.com/cse/search ## your can change to your site instead of the default site ##使用不蒜子添加访客统计详情参考搞定你的网站计数，具体做法很简单，就是在你的themes/your themes/layout/_partial/footer.ejs底部加入这段脚本 1&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后在&lt;p class=&quot;copyright&quot;&gt;&lt;/p&gt;中间添加如下统计信息即可 1本站总访问量 &lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次, 访客数 &lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 人次, 本文总阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次 不蒜子的官方服务网站是不蒜子，目前最大的弊端就是不开放注册，所以对于运行了一段时间的网站，不蒜子的数据都是从1开始，没办法设置，只有等后期开放注册之后，登入网站才能对统计计数进行设置。 ###Hexo主题 Next Yilia Maupassant Yelee Tranguilpeak Huxbloh Hacker]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 搭建Nginx+Rtmp服务器]]></title>
    <url>%2Fblog%2FMac%20%E6%90%AD%E5%BB%BANginx%2BRtmp%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[#Mac 搭建Nginx+Rtmp服务器 概述Mac安装RTMP服务器过程 一、安装Homebrew执行命令： 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 如果已经安装过，而想要卸载： 1ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; 二、安装nginx执行安装： 1brew install nginx-full --with-rtmp-module 通过操作以上步骤，nginx和rtmp模块就安装好了 三、运行nginx执行命令： 1nginx 出现Nginx页面信息，表示nginx服务器搭建成功了，而且已经安装了RTMP模块了。 四、配置nginx和rtmp下面开始来配置nginx的rtmp模块。首先，我们要看看nginx安装到哪里了： 1brew info nginx-full 出现如下类似信息： 12345678910111213141516171819202122232425==&gt; CaveatsDocroot is: /usr/local/var/wwwThe default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in /usr/local/etc/nginx/servers/.- Tips -Run port 80: $ sudo chown root:wheel /usr/local/Cellar/nginx-full/1.10.1/bin/nginx $ sudo chmod u+s /usr/local/Cellar/nginx-full/1.10.1/bin/nginxReload config: $ nginx -s reloadReopen Logfile: $ nginx -s reopenStop process: $ nginx -s stopWaiting on exit process $ nginx -s quitTo have launchd start homebrew/nginx/nginx-full now and restart at login: brew services start homebrew/nginx/nginx-fullOr, if you don&apos;t want/need a background service you can just run: nginx 从这些信息中，可以看到nginx.conf文件在： 1/usr/local/etc/nginx/nginx.conf nginx完整路径： 1/usr/local/Cellar/nginx-full/1.10.1/bin/nginx 通过以下打开nginx.conf配置文件来配置： 1vi /usr/local/etc/nginx/nginx.conf 直接滚动到最后一行，以就是在http {} 之后： 123456789101112131415161718192021//在http节点后面加上rtmp配置：rtmp &#123; server &#123; listen 1935; #直播流配置 application rtmplive &#123; live on; record off; #为 rtmp 引擎设置最大连接数。默认为 off max_connections 1024; &#125; application hls&#123; live on; hls on; hls_path /usr/local/var/www/hls; hls_fragment 1s; &#125; &#125; &#125; 重启nginx： 1/usr/local/Cellar/nginx-full/1.10.0/bin/nginx -s reload 五、安装ffmpeg输入以下命令来安装ffmpeg： 1brew install ffmpeg 安装这个需要等一段时间，然后准备一个视频文件作为来推流，我们在安装一个支持rtmp协议的视频播放器，Mac下可以用VLC。 六、ffmpeg推流123ffmpeg -re -i /Users/vvusu/Desktop/test.mov -vcodeclibx264 -acodec aac -f flv rtmp://localhost:5920/rtmplive/roomffmpeg -loglevel verbose -re -i Desktop/1.mp4 -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://127.0.0.1:1935/hls/movie 将视频推流到服务器后，打开VLC，然后file-&gt;open network-&gt;输入： 1rtmp://localhost:5920/rtmplive/room]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_部署MongoDB]]></title>
    <url>%2Fblog%2FMac%20%E9%83%A8%E7%BD%B2MongoDB%2F</url>
    <content type="text"><![CDATA[Mac_部署MongoDB1.安装brew install mongodb 第一次启动服务端,这里需要做一些准备工作. 1.默认mongodb 数据文件是放到根目录 data/db 文件夹下,如果没有这个文件,请自行创建. 1mkdir -p /data/db 2.如果你当前的环境变量还没有加入 mongod ,手动添加的环境变量中. 1nano ~/.bash_profile 添加mongodb安装目录到环境变量中 1export PATH=/usr/local/Cellar/mongodb/2.4.9/bin:$&#123;PATH&#125;&#125; 3.如果让环境变量马上生效? 执行下面的shell 1source ~/.bash_profile 4.修改mongodb配置文件,配置文件默认在/usr/local/etc 下的 mongod.conf 12345678systemLog:destination: filepath: /usr/local/var/log/mongodb/mongo.loglogAppend: truestorage:dbPath: /data/dbnet:bindIp: 127.0.0.1 第二行修改成数据库文件写入目录地址,如果准备连接非本地环境的mongodb数据库时,bind_ip = 0.0.0.0 即可. 5.尝试启动 mongod 好吧,万事开头难,mongodb 服务器没有启动起来,看最后一行错误提示已经退出,google 后得知是因为 /data/db 文件没有写入权限. 6.给 /data/db 文件夹赋权限 1sudo chown `id -u` /data/db ok,这一句搞定,继续尝试启动服务器端 ok,mongodb 服务端终于启动起来了.接着启动mongodb 客户端 1/usr/local/etc$ mongo]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_国际化]]></title>
    <url>%2Fblog%2FiOS_%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[#iOS_国际化 1. 创建一个新应用在Xcode的Single Application View模版中，Xcode对English做了本地化。 国际化了两个文件：Main.storyboard和LaunchScreen.storyboard 2. 开始国际化选中project，在上图的Localizations选项下，添加简体中文；Xcode会询问你是否国际化以下文件，这个地方并不重要，因为项目中所有的资源文件都可以很方便的国际化和去国际化。 观察一下有哪些文件是可以国际化的： xib和storyboard资源文件； info.plist文件 strings文件等等 简而言之，除了代码文件和xcassets，都可以国际化。 3. 国际化代码中的文本国际化是基于.strings文件的，该文件的内容只是简单的key value对，如下： 12&quot;KEY1&quot; = &quot;CONTENT1&quot;; &quot;KEY2&quot; = &quot;CONTENT2&quot;; 其中Localizable和InfoPlist两个strings文件尤为重要，前者在这一小节介绍，后者在国际化info.plist中介绍。 如果你在.m文件中，使用代码的方式设置按钮的title，可以使用NSLocalizedString宏定义 12#define NSLocalizedString(key, comment) [[NSBundle mainBundle] localizedStringForKey:(key) value:@&quot;&quot; table:nil] 该方法会在Localizable.strings中查找key对应的value。 完整处理过程： 新建Localizable.strings文件； 打开右侧file inspector，打开Localization选项，选中Base和中文简体； 如下，Localizable.strings文件就会从一个文件变成两个文件，编译各种语言对应的文件即可； 在代码中使用NSLocalizedString(key, nil)，key为Localizable.strings中的key。 注释：NSLocalizedString宏定义中的comment参数并没有实际意义。 4. 国际化storyboard和xib文件国际化storyboard和xib文件国际化也是在file inspector的Localization中。 国际化的结果就是在Xcode中可以看到一个文件变成了对应的两个文件。 再观察一下目录结构： Base.lproj: en.lproj: 这类资源文件，Xcode的处理方式是，原文件放在Base中，在其它语言版本中只有一个对应文件名的strings文件，再看一下LaunchScreen,strings的部分内容： 123456/* Class = &quot;UILabel&quot;; text = &quot;Detail view content goes here&quot;; ObjectID = &quot;0XM-y9-sOw&quot;; */&quot;0XM-y9-sOw.text&quot; = &quot;Detail view content goes here&quot;;/* Class = &quot;UITableViewController&quot;; title = &quot;Master&quot;; ObjectID = &quot;7bK-jq-Zjz&quot;; */&quot;7bK-jq-Zjz.title&quot; = &quot;Master&quot;; 其中的ObjectID是什么？ 用source code的方式，打开LaunchScreen.storyboard，全局搜索一下 0XM-y9-sOw，结果如下： 12&lt;label clipsSubviews=&quot;YES&quot; userInteractionEnabled=&quot;NO&quot; contentMode=&quot;scaleToFill&quot; text=&quot;Detail view content goes here&quot; textAlignment=&quot;center&quot; lineBreakMode=&quot;tailTruncation&quot; minimumFontSize=&quot;10&quot; translatesAutoresizingMaskIntoConstraints=&quot;NO&quot; id=&quot;0XM-y9-sOw&quot;&gt; ObjectID是原文件中对应的对象。 5. 国际化info.plist按照上面的思路，国际化一下info.plist，然后编译，碰到了什么问题？ Xcode找不到info.plist。 因为通过file inspector的Localization，Xcode会创建两个info.plist分别放在Base.lproj和zh-Hans.lproj文件夹下。 还记得上面没讲的InfoPlist.strings吗？ 处理过程： 新建一个InfoPlist.strings文件； Localization该文件； 编辑对应语言的InfoPlist.strings文件即可。比如，英文版本应用名叫English，中文版本叫中文，如下： 123456&quot;CFBundleDisplayName&quot; = &quot;English&quot;;和&quot;CFBundleDisplayName&quot; = &quot;中文&quot;; 7. 练习：国际化音频文件以下是必要步骤的简单描述： 把音频文件A拷贝到项目中。 打开音频文件inspector，选择本地化按钮，选择了Base和简体中文作为支持语言。 重命名第二个音频文件B，和第一个名字A一样，然后将其拷贝到es.lproj文件夹。 确保你在Finder提示中选择了“Replace File”。 9. 国际化与多target问题问题描述：我们应用有4个分身（4个相似的app），同时还做了国际化，此时我就迷茫了！四个应用有a,b,c,d四个info.plist文件名，但是国际化info.plist的文件名都是InfoPlist.strings。。。 解决办法： 创建四个文件夹； 在四个文件夹中分别创建一个InfoPlist.strings； 4个InfoPlist.strings关联到不同target。OK啦～]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装Python3.5]]></title>
    <url>%2Fblog%2FCentOS7_%E5%AE%89%E8%A3%85Python3.5%2F</url>
    <content type="text"><![CDATA[CentOS7 安装Python3.5安装步骤 编译环境准备准备一下编译环境，防止出现安装错误 12yum groupinstall &apos;Development Tools&apos;yum install zlib-devel bzip2-devel openssl-devel ncurese-devel 下载python3.5代码包这里选择下载最近版本的Python3.5.1 (2016-05) 1wget https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tar.xz 编译 1234tar Jxvf Python-3.5.1.tar.xzcd Python-3.5.1./configure --prefix=/usr/local/python3make &amp;&amp; make install Python3.5.1 安装编译安装时会默认安装 pip 如果出现： 1Ignoring ensurepip failure: pip 1.5.6 requires SSL/TLS 未安装编译环境，重新安装该编译环境并重新编译 Python3.5.1 1yum install zlib-devel bzip2-devel openssl-devel ncurese-devel 更换系统默认 Python 版本备份旧版本 Python 1mv /usr/bin/python usr/bin/python2.7 新建指向新版本 Python 以及 pip 的软连接 12ln -s /usr/local/python3/bin/python3.5 /usr/bin/pythonln -s /usr/local/python3/bin/pip3 /usr/bin/pip 检验 Python 及 pip 版本 12python -Vpip -V 5.更新 yum 相关设置因 yum 的功能依赖 Python2 更改默认 Python版本后会导致 yum无法正常工作执行以下命令: 1vi /usr/bin/yum 打开文件，修改第一行为： 1#!/usr/bin/python2.7 若执行 yum 时出现以下错误： 1File &quot;/usr/libexec/urlgrabber-ext-down&quot;, line 28 执行以下更改,打开该文件并修改首行为： 1#!/usr/bin/python2.7 其他执行 yum 时，若出现以下 Error: 1Error: Delta RPMs disabled because /usr/bin/applydeltarpm not installed. 执行以下安装可解决： 1yum install deltarpm 版本共存如果你希望同时使用多版本 Python ，例如在保持系统原有版本 Python2.x 不变的情况下使用 Python 3.x,可以考虑使用 virtualenv 构建合适版本的虚拟环境： python2.7 环境下搭建 python3.x 环境#安装 pip 12yum install python-setuptoolseasy_install pip #安装virtualenv 1pip install virtualenv #在当前文件夹下构建虚拟环境 1virtualenv -p /usr/local/python3/bin/python3 venv #启动虚拟环境 1source venv/bin/activate #退出虚拟环境deactivatevirtualenv 详细使用说明，参见 Virtualenv]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 SS-Panel]]></title>
    <url>%2Fblog%2FCentos7_SS-Panel%2F</url>
    <content type="text"><![CDATA[Centos7 SS-Panelss-panel与manyuser搭建ss前端与后端Step 01git clone https://github.com/orvice/ss-panel.git Step 112$ curl -sS https://getcomposer.org/installer | php$ php composer.phar install Step 21cp .env.example .env then edit .env 1chmod -R 777 storage Step 3Import the sql to you mysql database. Step 4Nginx Config example: if you download ss-panel on path /home/www/ss-panel 12345root /home/www/ss-panel/public;location / &#123; try_files $uri $uri/ /index.php$is_args$args;&#125; 配置ss-panel v3 配置说明，请根据说明合理选择密码加密方式，认证方式等。 修改站点以及数据库配置 1vim .env Auth Driver 认证设置ss-panel v3支持多种存储用户认证信息的方式： cookie 同v2的认证方式，不推荐。redis 使用Redis存储，推荐此方式。推荐使用redis 安装Redis1apt-get install redis-server 密码加密方式md5 不推荐sha256 推荐 添加管理员在网站根目录下执行 1php xcat createAdmin 根据提示创建管理员帐号。 创建成功后登录可以在/admin进行管理。 重置流量 1php xcat resetTraffic Nginx 配置虚拟主机配置文件例子； 1234567891011121314151617181920location / &#123; try_files $uri $uri/ /index.php$is_args$args;&#125;location ~ \.php &#123; try_files $uri =404; fastcgi_split_path_info ^(.+\.php)(/.+)$; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $fastcgi_script_name; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9004;&#125;location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|ico)$ &#123; expires 30d; access_log off; &#125;location ~ .*\.(js|css)?$ &#123; expires 7d; access_log off; &#125; 在主机上运行fastcgi 1php-cgi -b 127.0.0.1:9004 停用系统防火墙12systemctl stop iptablessystemctl stop firewalld 安装Manyuser项目地址：https://github.com/mengskysama/shadowsocks-rm/tree/manyuser 1、先安装需要的环境依赖12Debian / Ubuntu:apt-get install python-pip python-m2crypto CentOS: 12yum install m2crypto python-setuptoolseasy_install pip 2、安装cymysql1pip install cymysql 3、安装shadowsocks-manyuser12345678git clone -b manyuser https://github.com/mengskysama/shadowsocks.git或者git clone -b manyuser https://github.com/mengskysama/shadowsocks-rm.gitSSR第三方版git clone -b manyuser https://github.com/breakwa11/shadowsocks.git多用户版配置在第一层ss目录下如果提示没有安装git，则先安装gityum -y install git 通过phpmyadmin创建数据库shadowsocks（名称随意），然后将shadowsocks-manyuser文件夹中的shadowsocks.sql导入到你创建的数据库中。 4、配置数据库连接cd /用户名/shadowsocks/shadowsocks 打开Config.py所在文件夹 编辑Config.py文件：vi Config.py，修改对应的端口、密码等等操作。如下格式 12345678910111213141516# ConfigMYSQL_HOST = &apos;127.0.0.1&apos; #这一行是服务器IP，127.0.0.1表示本机MYSQL_PORT = 3306 #数据库端口号MYSQL_USER = &apos;ss&apos; #数据库用户名MYSQL_PASS = &apos;ss&apos; #数据库密码MYSQL_DB = &apos;shadowsocks&apos; #数据库名称MANAGE_PASS = &apos;ss233333333&apos;# if you want manage in other server you should set this value to global ipMANAGE_BIND_IP = &apos;127.0.0.1&apos;# make sure this port is idleMANAGE_PORT = 23333 5、开启服务1python server.py 如果放在后台运行则可以，nohup python server.py &amp;nohup用法可以百度，也可以用screen或者配置supervisor进程守护。我是centos用的screen，方法如下： 123screen -S shadowsockscd /root/shadowsocks/shadowsocks/python server.py 此时按住Ctrl+a，然后按d退出就可以了。查看screen运行任务可以screen -ls可以看到刚才创建的ss任务在运行。如果需要恢复执行： 1screen -r shadowsocks 当然，出意外的话killall也是可以。 Shadowsocks开机自动启动并后台运行vi /etc/rc.local用vi编辑器添加以下内容（先按键盘Ins键，切换到编辑模式）： 12cd /root/shadowsocks/shadowsocksscreen -dmS Shadowsocks python server.py 然后Esc退出编辑，Shift+;打出英文半角冒号，然后wq，回车，保存文件。（screen -dmS Shadowsocks python server.py，也就是让程序运行后就在后台了。）至此多用户SS后端安装完毕。 debian下使用supervisor进程守护的方法安装supervisorapt-get install supervisor配置supervisor进程守护在目录/etc/supervisor/conf.d/下， 新建一个文件，名字：shadowsocks.conf在shadowsocks.conf文件里编辑添加： 1234[program:shadowsocks]command=python /root/shadowsocks/shadowsocks/server.py -c /root/shadowsocks/shadowsocks/config.json #/此处目录请自行修改autorestart=trueuser=root 修改以下文件/etc/profile/etc/default/supervisor在文件结尾处添加以下3行内容 123ulimit -n 51200ulimit -Sn 4096ulimit -Hn 8192 启动supervisorservice supervisor start #启动supervisorctl reload #重载debug查看连接日志等supervisorctl tail -f shadowsocks stderr #Ctrl+C 取消查看 centos使用supervisor安装easy_install supervisor运行echo_supervisord_conf测试是否安装成功。创建配置文件：echo_supervisord_conf &gt; /etc/supervisord.conf修改配置文件：在supervisord.conf最后增加： 12345[program:shadowsocks]command = python /root/shadowsocks/shadowsocks/server.py -c /root/shadowsocks/shadowsocks/config.jsonautostart=trueautorestart=truestartsecs=3 使用指定配置文件启动：/usr/bin/supervisord -c /etc/supervisord.conf/-c 表示配置文件的路径，读取这里个配置文件，之前也是可以根据自己的情况放在不同的文件夹下修改配置文件之后：supervisorctl reload 重载 服务重新启动debug查看连接日志：supervisorctl tail -f shadowsocks stderr #Ctrl+C 取消查看设置supervisord开机启动编辑文件：vi /etc/rc.local在末尾另起一行添加supervisord，保存退出（和上文类似）。另centos7还需要为rc.local添加执行权限chmod +x /etc/rc.local至此运用supervisord控制shadowsocks开机自启和后台运行设置完成常用命令控制命令基本都通过supervisorctl执行，输入help可以看到命令列表。这是一些常用命令： 1234获得所有程序状态 supervisorctl status关闭目标程序 supervisorctl stop spider启动目标程序 supervisorctl start spider关闭所有程序 supervisorctl shutdown]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 Shadowscoks搭建]]></title>
    <url>%2Fblog%2FCentOS7_Shadowscoks%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[shadowsocks 简介shadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。 shadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。 因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。 购买 VPS 服务器主流的 VPS（虚拟主机）服务器提供商有三家： linode digital ocean bandwagon 下面的比上面的便宜。如果只是自用，bandwagon 足够。一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。 安装 shadowsocks在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。 1yum install python-setuptools pip 配置 Shadowsocks打开 shell，使用 VPS 服务商提供的 root 用户和密码 SSH 登录 VPS。然后执行如下命令： 1234567Debian/Ubuntu:apt-get install python-pippip install shadowsocksCentOS:yum install python-setuptools &amp;amp;&amp;amp; easy_install pippip install shadowsocks shadowsocks 就安装好了。 有时 Ubuntu 会遇到第一个命令安装 python-pip 时找不到包的情况。pip 官方给出了一个安装脚本，可以自动安装 pip。先下载脚本，然后执行即可： 12wget https://bootstrap.pypa.io/get-pip.pypython get-pip.py 编写配置文件 shadowsocks 启动时的参数，如服务器端口，代理端口，登录密码等，可以通过启动时的命令行参数来设定，也可以通过 json 格式的配置文件设定。推荐使用配置文件，方便查看和修改。 用 vi 新建一个配置文件： 1vi /etc/shadowsocks.json 然后输入如下内容： 12345678910&#123; &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8000, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false&#125; 保存退出。 上方代码的解释：字段名 含义server 服务端监听的地址，服务端可填写0.0.0.0server_port 服务端的端口local_address 本地端监听的地址local_port 本地端的端口password 用于加密的密码timeout 超时时间，单位秒method 默认 “aes-256-cfb”，参见加密方法fast_open 是否使用 TCP_FASTOPEN, true / falseworkers worker 数量，Unix/Linux 可用，如果不理解含义请不要改 如要你需要分享SS服务给朋友或家人，可以配置多个SS账户，具体可以参考下面的代码。12345678910111213&#123;&quot;server&quot;:&quot;your_server_ip&quot;,&quot;port_password&quot;:&#123; &quot;8381&quot;:&quot;pass1&quot;, &quot;8382&quot;:&quot;pass2&quot;, &quot;8383&quot;:&quot;pass3&quot;, &quot;8384&quot;:&quot;pass4&quot; &#125;,&quot;timeout&quot;:60,&quot;method&quot;:&quot;rc4-md5&quot;,&quot;fast_open&quot;:false,&quot;workers&quot;:1&#125; 启动 shadowsocks如果已经写好了配置文件，启动 shadowsocks 服务器的命令如下： 1ssserver -c /etc/shadowsocks.json 后台启动和停止 shadowsocks 服务器： 12ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop shadowsocks 的日志保存在/var/log/shadowsocks.log安装并启动 shadowsocks 客户端 shadowsocks 支持 windows、Mac OS X、Linux、Android、iOS 等多个平台。iOS平台上使用Suger 软件进行代理。 shadowsocks 项目 Github 主页在这里。 里面可以找到客户端下载地址。 下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。 客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。 PAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。 使用 switchyOmega 实现自动切换代理switchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。 chrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。 安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。 创建 shadowsocks 情景模式 新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。 现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表 设置自动切换模式 在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。 然后在下面的规则列表地址中填写 1https://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt 规则列表格式选择 AutoProxy。 然后点击立即更新情景模式， 更新完成后会有提示。 点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。 客户端Shadowsocks GUI 服务端启动完成后需要配置本地端，在此网页根据自己的系统下载最新的Shadowsocks GUI http://sourceforge.net/projects/shadowsocksgui/files/dist/相关说明参见此项目的GitHub https://github.com/shadowsocks/shadowsocks-gui win版以.xz结尾，可能需要新版Winrar才能解压。 SwitchyOmega在Chrome浏览器中下载插件SwitchyOmega（新版的SwitchySharp，个人感觉自动规则切换更加迅速）并如图配置即可使用代理访问shadowsocks，其他浏览器类似 。 设置完成后点击Chrome右上角SwitchyOmega标志，当为如图所示时即为使用代理上网 添加自定义规则如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。 这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。 导入和导出 switchyOmega 设置 如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。 在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。 shadowsocks服务器TCP优化1nano /etc/sysctl.conf 1234567891011121314151617181920212223242526272829303132fs.file-max = 51200#提高整个系统的文件限制net.ipv4.tcp_syncookies = 1#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 0#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；#为了对NAT设备更友好，建议设置为0。net.ipv4.tcp_fin_timeout = 30#修改系統默认的 TIMEOUT 时间。net.ipv4.tcp_keepalive_time = 1200#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。net.ipv4.ip_local_port_range = 10000 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）net.ipv4.tcp_max_syn_backlog = 8192#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。net.ipv4.tcp_max_tw_buckets = 5000#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。#额外的，对于内核版本新于**3.7.1**的，我们可以开启tcp_fastopen：net.ipv4.tcp_fastopen = 3# increase TCP max buffer size settable using setsockopt()net.core.rmem_max = 67108864 net.core.wmem_max = 67108864 # increase Linux autotuning TCP buffer limitnet.ipv4.tcp_rmem = 4096 87380 67108864net.ipv4.tcp_wmem = 4096 65536 67108864# increase the length of the processor input queuenet.core.netdev_max_backlog = 250000# recommended for hosts with jumbo frames enablednet.ipv4.tcp_mtu_probing=1 保存并退出该文件,然后使用以下指令使配置生效： 1sysctl -p]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 搭建IPSec-L2TP]]></title>
    <url>%2Fblog%2FCentOS7_%E6%90%AD%E5%BB%BAIPSec-L2TP%2F</url>
    <content type="text"><![CDATA[1.安装ipsecopenswan 是linux 下vpn协议ipsec的一种实现，centos 7 带的是它的开源社区分支，现在叫libreswan, 我们通过yum来安装 1yum install libreswan or yum install openswan 修改配置文件 1、编辑 /etc/ipsec.conf 文件末尾找到 include /etc/ipsec.d/*.conf 这行解注 2、在 /etc/ipsec.d/ 目录中新建一个配置文件 l2tp_vpn.conf 1vi /etc/ipsec.d/l2tp_vpn.conf 内容如下： 12345678910111213141516conn L2TP-PSK-NAT rightsubnet=vhost:%priv also=L2TP-PSK-noNATconn L2TP-PSK-noNAT authby=secret pfs=no auto=add type=transport keyingtries=3 rekey=no ikelifetime=4h salifetime=4h left=YOU.SERVER.PUBLIC.IP leftprotoport=17/1701 right=%any rightprotoport=17/%any 注意将YOU.SERVER.PUBLIC.IP替换成你的VPS公网地址 配置项的说明可以参考： https://libreswan.org/man/ipsec.conf.5.html 设置共享密钥 cat /etc/ipsec.secrets文件内容如下： include /etc/ipsec.d/*.secrets 然后在 /etc/ipsec.d/ 目录中新建一个配置文件 l2tp_vpn.secrets 内容如下： 1YOU.SERVER.PUBLIC.IP %any: PSK &quot;woaini&quot; 注意将YOU.SERVER.PUBLIC.IP替换成你的公网地址 woaini 即是共享密钥,可以替换成你自己的。 修改包转发设置 编辑/etc/sysctl.conf ， 修改以下选项的值（若没有就添加） 1234567891011net.ipv4.ip_forward = 1net.ipv4.conf.all.rp_filter = 0net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.eth0.rp_filter = 0net.ipv4.conf.all.send_redirects = 0net.ipv4.conf.default.send_redirects = 0net.ipv4.conf.all.accept_redirects = 0net.ipv4.conf.default.accept_redirects = 0 然后执行 sysctl -p 启动 ipsec 终端执行 systemctl start ipsec 来启动ipsec.终端执行 systemctl enable ipsec 将ipsec 加入开机启动。 然后执行 systemctl status ipsec 可以看到状态为 Active: active (running) 执行 ipsec verify, 输出如下： 12345678910111213141516171819202122Verifying installed system and configuration filesVersion check and ipsec on-path [OK]Libreswan 3.8 (netkey) on 3.15.4-x86_64-linode45Checking for IPsec support in kernel [OK]NETKEY: Testing XFRM related proc values ICMP default/send_redirects [OK] ICMP default/accept_redirects [OK] XFRM larval drop [OK]Pluto ipsec.conf syntax [OK]Hardware random device [N/A]Two or more interfaces found, checking IP forwarding [OK]Checking rp_filter [OK]Checking that pluto is running [OK]Pluto listening for IKE on udp 500 [OK]Pluto listening for IKE/NAT-T on udp 4500 [OK]Pluto ipsec.secret syntax [OK]Checking NAT and MASQUERADEing [TEST INCOMPLETE]Checking &apos;ip&apos; command [OK]Checking &apos;iptables&apos; command [OK]Checking &apos;prelink&apos; command does noted interfere with FIPSChecking for obsolete ipsec.conf options [OK]Opportunistic Encryption [DISABLED] NAT and MASQUERADEing [TEST INCOMPLETE] 不用担心，这不是说checking没完，是ipsec这个检查NAT的功能还没开发完， man ipsec verify 可以看到说明 修改防火墙设置 centos 7 防火墙服务用的是 firewalld。防火墙的配置方法感觉比以前更容易理解很多。 让防火墙允许ipsec通过 1firewall-cmd --add-service=ipsec --permanent 如果报 1FirewallD is not running 是你的防火墙还没开。 可以执行 systemctl start firewalld 开启防火墙。 执行 systemctl status firewalld 查看状态 执行 systemctl enable firewalld 让其开机自启 。 之前没开启防火墙的此时记得执行 firewall-cmd –add-service=ipsec –permanent 这个哦。 因为默认的ipsec service 只开放了500端口，如果要穿nat 需要再开放 4500端口。 扫行 cp /lib/firewalld/services/ipsec.xml /etc/firewalld/services/ipsec.xml 拷贝默认的ipsec配置到自定义目录下。 然后编辑它， vi /etc/firewalld/services/ipsec.xml 加入如下行： 1&lt;port protocol=&quot;udp&quot; port=&quot;4500&quot;&gt; 执行 firewall-cmd –reload 生效 可以再执行 iptables -n -L 确认一下是不是500和4500端口开启了。 123456Chain IN_public_allow (1 references)target prot opt source destinationACCEPT ah -- 0.0.0.0/0 0.0.0.0/0 ctstate NEWACCEPT esp -- 0.0.0.0/0 0.0.0.0/0 ctstate NEWACCEPT udp -- 0.0.0.0/0 0.0.0.0/0 udp dpt:500 ctstate NEWACCEPT udp -- 0.0.0.0/0 0.0.0.0/0 udp dpt:4500 ctstate NEW 测试ipsec配置 在客户端新建 ipsec+l2tp 的连接，填好服务器地址和共享密码，点击连接。 在服务器端执行 tail -100f /var/log/secure 看日志，如果出现了类似 1STATE_QUICK_R2: IPsec SA established transport mode 这样的日志就说明 ipsec 没问题了。 在客户端 如果你用MAC OSX，也可以看 tail /var/log/system.log |grep ppp，有类似 1pppd[2056]: IPSec connection established 说明客户端也是成功了。 至此ipsec 配置完成。 2.安装l2tpxl2tpd是l2tp的实现，centos 6 是可以通过添加 epel再yum安装的。但是笔者写此文的时候centos 7的epel源中貌似还没有这个包，所以只能比较土地编译安装了。也许你可以尝试 yum install xl2tpd 试试看现在是不是已经有打包了。 或者打开 http://dl.fedoraproject.org/pub/epel/ 找找看centos 7中现在是不是加上了 编译安装 xl2tpd 安装gcc和依赖 yum install gcc libpcap-devel 从这里找到最新的release包 https://github.com/xelerance/xl2tpd/releases 下载解压源码cd ~ 12wget https://github.com/xelerance/xl2tpd/archive/v1.3.6.tar.gztar -xvzf v1.3.6.tar.gz 编译安装 123makemake install 配置xl2tpd 编辑 /etc/xl2tpd/xl2tpd.conf (没有的话就创建一个)，内容如下： 12345678910111213141516[global]listen-addr = YOU.SERVER.PUBLIC.IPauth file = /etc/ppp/chap-secretsport = 1701[lns default]ip range = 10.5.1.10-10.5.1.100local ip = 10.5.1.2; leave chap unspecified for maximum compatibility with windows, iOS, etc; require chap = yesrefuse pap = yesrequire authentication = yesname = L2TPVPNppp debug = yespppoptfile = /etc/ppp/options.xl2tpdlength bit = yes 注意将YOU.SERVER.PUBLIC.IP替换成你的公网地址 编辑 /etc/ppp/options.xl2tpd (没有的话就创建一个)，内容如下： 123456789101112131415161718192021222324252627282930ipcp-accept-localipcp-accept-remote# 使用google的 8.8.8.8ms-dns 8.8.8.8ms-dns 8.8.4.4noccpauthcrtsctsidle 1800# 将mtu改小，对ios等设备连接貌似有用。mtu 1356mru 1356nodefaultroutedebuglockproxyarpconnect-delay 5000`最后编辑 /etc/ppp/chap-secrets (没有的话就创建),格式如下：`# Secrets for authentication using CHAP# client server secret IP addressesusername * vvusu * 这样添加的客户帐号就是username ,密码是woaini. 修改防火墙 执行 firewall-cmd –new-service=xl2tpd –permanent 如果是yum 安装的可以找找看是不是 /lib/firewalld/services 下有xl2tpd的文件，有的话拷贝到 /etc/firewalld/services 这样会在 /etc/firewalld/services/ 生成一个 xl2tpd.xml 文件。编辑&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;service&amp;gt; &amp;lt;short&amp;gt;xl2tpd&amp;lt;/short&amp;gt; &amp;lt;port protocol=&quot;udp&quot; port=&quot;1701&quot;/&amp;gt; &amp;lt;/service&amp;gt;执行firewall-cmd –add-service=xl2tpd –permanent，添加。 可以执行iptables -n -L 看一下 1701 udp端口是不是打开了。 如果还没有生效的话 执行firewall-cmd –reload重新载入一下。 连接测试 执行xl2tpd -D输入类似如下 12xl2tpd[11944]: L2TP kernel support not detected (try modprobing l2tp_ppp and pppol2tp)xl2tpd[11944]: open_controlfd: Unable to open /var/run/xl2tpd/l2tp-control for reading. kernel support的不理它。 后面那行需要创建一下目录 mkdir /var/run/xl2tpd 然后客户端发起连接测试一下。 记得帐号密码在 /etc/ppp/chap-secrets, 共享密钥在/etc/ipsec.d/l2tp_vpn.secrets哦 xl2tpd 输出类似如下 1Call established with xx.xx.xx.xx , Local: 28828, Remote: 10057, Serial: 1 表示连接成功了。 现在就只差最后一步了，有点开心。 将防火墙开启 MASQUERADE 就可以通过vpn翻墙了 1firewall-cmd --add-masquerade --permanent 重新加载一下， firewall-cmd –reload OK 至此，所有的配置完成。 在你的浏览器里 打开 http://facebook.com 试试看吧。 it works! 最后将xl2tpd 加到开机启动 编辑 /usr/lib/systemd/system/xl2tpd.service 文件 ，内容如下。 12345678910111213[Unit]Description=xl2tpd server daemonAfter=syslog.target network.target ipsec.service[Service]Type=simplePIDFile=/var/run/xl2tpd/xl2tpd.pidExecStart=/usr/local/sbin/xl2tpd -p /var/run/xl2tpd/xl2tpd.pidRestart=on-abortKillMode=process[Install]WantedBy=multi-user.target 然后执行systemctl daemon-reload 再执行 systemctl restart xl2tpd, systemctl enable xl2tpd]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 Firewalld]]></title>
    <url>%2Fblog%2FCentOS7_Firewalld%2F</url>
    <content type="text"><![CDATA[CentOS7 Firewalld安装： 1# yum install firewalld` 图形界面： 1# yum install firewall-config` 介绍防火墙守护 firewalld 服务引入了一个信任级别的概念来管理与之相关联的连接与接口。它支持 ipv4 与 ipv6，并支持网桥，采用 firewall-cmd (command) 或 firewall-config (gui) 来动态的管理 kernel netfilter 的临时或永久的接口规则，并实时生效而无需重启服务。 zone Firewall 能将不同的网络连接归类到不同的信任级别，Zone 提供了以下几个级别 drop: 丢弃所有进入的包，而不给出任何响应 block: 拒绝所有外部发起的连接，允许内部发起的连接 public: 允许指定的进入连接 external: 同上，对伪装的进入连接，一般用于路由转发 dmz: 允许受限制的进入连接 work: 允许受信任的计算机被限制的进入连接，类似 workgroup home: 同上，类似 homegroup internal: 同上，范围针对所有互联网用户 trusted: 信任所有连接 过滤规则 source: 根据源地址过滤 interface: 根据网卡过滤 service: 根据服务名过滤 port: 根据端口过滤 icmp-block: icmp 报文过滤，按照 icmp 类型配置 masquerade: ip 地址伪装 forward-port: 端口转发 rule: 自定义规则 其中，过滤规则的优先级遵循如下顺序 source interface firewalld.conf 其中，过滤规则的优先级遵循如下顺序 source interface firewalld.conf 二、使用方法 # systemctl unmask firewalld #解除锁定 # systemctl start firewalld # 启动 # systemctl enable firewalld # 开机启动 # systemctl stop firewalld # 关闭 # systemctl disable firewalld # 取消开机启动 具体的规则管理，可以使用 firewall-cmd，具体的使用方法可以 $ firewall-cmd --help --zone=NAME # 指定 zone --permanent # 永久修改，--reload 后生效 --timeout=seconds # 持续效果，到期后自动移除，用于调试，不能与 --permanent 同时使用 查看规则查看运行状态 1$ firewall-cmd --state 查看已被激活的 Zone 信息 $ firewall-cmd --get-active-zones public interfaces: eth0 eth1 查看指定接口的 Zone 信息 $ firewall-cmd --get-zone-of-interface=eth0 public 查看指定级别的接口 $ firewall-cmd --zone=public --list-interfaces eth0 查看指定级别的所有信息，譬如 public $ firewall-cmd --zone=public --list-all public (default, active) interfaces: eth0 sources: services: dhcpv6-client http ssh ports: masquerade: no forward-ports: icmp-blocks: rich rules: 查看所有级别被允许的信息 $ firewall-cmd --get-service 查看重启后所有 Zones 级别中被允许的服务，即永久放行的服务 $ firewall-cmd --get-service --permanent 管理规则 123456# firewall-cmd --panic-on # 丢弃# firewall-cmd --panic-off # 取消丢弃# firewall-cmd --query-panic # 查看丢弃状态# firewall-cmd --reload # 更新规则，不重启服务# firewall-cmd --complete-reload # 更新规则，重启服务#firewall-cmd --reload # 效果同上 添加某接口至某信任等级，譬如添加 eth0 至 public，永久修改 # firewall-cmd --zone=public --add-interface=eth0 --permanent 设置 public 为默认的信任级别 # firewall-cmd --set-default-zone=public A. 管理端口列出 dmz 级别的被允许的进入端口 # firewall-cmd --zone=dmz --list-ports 允许 tcp 端口 8080 至 dmz 级别 # firewall-cmd --zone=dmz --add-port=8080/tcp 允许某范围的 udp 端口至 public 级别，并永久生效 # firewall-cmd --zone=public --add-port=10000-20000/tcp --permanent B. 网卡接口列出 public zone 所有网卡 # firewall-cmd --zone=public --list-interfaces 将 eth0 添加至 public zone，永久 # firewall-cmd --zone=public --permanent --add-interface=eth0 eth0 存在与 public zone，将该网卡添加至 work zone，并将之从 public zone 中删除 # firewall-cmd --zone=work --permanent --change-interface=eth0 删除 public zone 中的 eth0，永久 # firewall-cmd --zone=public --permanent --remove-interface=eth0 C. 管理服务添加 smtp 服务至 work zone # firewall-cmd --zone=work --add-service=smtp 移除 work zone 中的 smtp 服务 # firewall-cmd --zone=work --remove-service=smtp D. 配置 external zone 中的 ip 地址伪装查看 # firewall-cmd --zone=external --query-masquerade 打开伪装 # firewall-cmd --zone=external --add-masquerade 关闭伪装 # firewall-cmd --zone=external --remove-masquerade E. 配置 public zone 的端口转发要打开端口转发，则需要先 # firewall-cmd --zone=public --add-masquerade 然后转发 tcp 22 端口至 3753 # firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=3753 转发 22 端口数据至另一个 ip 的相同端口上 # firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toaddr=192.168.1.100 转发 22 端口数据至另一 ip 的 2055 端口上 # firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=2055:toaddr=192.168.1.100 F. 配置 public zone 的 icmp查看所有支持的 icmp 类型 # firewall-cmd --get-icmptypes destination-unreachable echo-reply echo-request parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded 列出 # firewall-cmd --zone=public --list-icmp-blocks 添加 echo-request 屏蔽 # firewall-cmd --zone=public --add-icmp-block=echo-request [--timeout=seconds] 移除 echo-reply 屏蔽 # firewall-cmd --zone=public --remove-icmp-block=echo-reply G. IP 封禁 123456789101112#仅允许部分IP访问本机服务配置#firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.4/24&quot; service name=&quot;http&quot; accept&quot; #不允许部分IP访问本机服务配置 # firewall-cmd --permanent --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;222.222.222.222&apos; reject&quot;#仅允许部分IP访问本机端口配置firewall-cmd --permanent --zone=public --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.0.4/24&quot; port protocol=&quot;tcp&quot; port=&quot;8080&quot; accept&quot;``` H. 其他操作 检查ftp服务的21端口是否开放 iptables -L -n | grep 21ACCEPT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:21 ctstateNEW1查询ftp服务启用状态 firewall-cmd –query-service ftp1查看当前规则 firewall-cmd –list-all`]]></content>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_Python环境搭建]]></title>
    <url>%2Fblog%2FMac%20Python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Mac_Python环境搭建安装 Python Mac系统自带Python2.7, 这个其实作为工具来说已经完全够用了. 如果想学习最新的Python3.x 或者有系统洁癖不想在系统的Python上装第三方包, 可以使用homebrew单独安装新的Python. 安装 Pip 理论上说安装好python就自带pip工具了, 如果真的没有的话, 可以手动安装. 如果你独立安装python, 先使用which python看看当前环境是否正确. 下载pip安装脚本 1wget https://bootstrap.pypa.io/get-pip.py 安装pip sudo python get-pip.py如果给python3安装pip, 则使用对应的 python3 命令安装即可. 安装 virtualenv virtualenv是Python的虚拟化环境, 类似于虚拟机的作用, 相当于你一台电脑可以有多个单独的Python环境, 这是非常有用的. 因为python的软件包之间的依赖程度很高, 有可能软件A和软件B 赖软件C不同版本, 这样有可能会导致不兼容. 譬如说: scrapy依赖six 1.5, 但是在el capitan自带了个six 1.4, 由于Mac自带的一些程序依赖于six 1.4. 系统是不允许你去升级six的. 这个时候使用虚拟化环境就能解决我们的问题. 命令行安装 1pip install virtualenv 创建虚拟环境 1virtualenv --distribute venv 激活虚拟环境 1source venv/bin/activate 这时候命令行的的python就指向venv目录了, 退出虚拟环境 关闭终端即可.]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_启动Mysql错误]]></title>
    <url>%2Fblog%2FMac%20%E5%90%AF%E5%8A%A8Mysql%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Mac_启动Mysql错误① Check if mysql is properly installed and also set up. 1brew info mysql If it’s not installed then google for how to install ‘mysql through homebrew’. If it is installed do not forget to set up your mysql by doing what homebrew tells you: 12345678910We&apos;ve installed your MySQL database without a root password. To secure it run: mysql_secure_installationTo connect run: mysql -urootTo have launchd start mysql now and restart at login: brew services start mysqlOr, if you don&apos;t want/need a background service you can just run: mysql.server start In your terminal do everything above. If you got errors, first check if your mysql server is running:1mysql.server start Then try mysql_secure_installation and/or mysql -uroot to try and get in. 1ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2) In case of this error try: mysql -uroot -h 127.0.0.1 I don’t know why but it selects the wrong host by default. If this still doesn’t work maybe you already set a password, in that case you need to add -p to the command: mysql -uroot -h 127.0.0.1 -p If even this fails maybe it’s a permission problem. Try: 12sudo chown -R _mysql:mysql /usr/local/var/mysqlsudo mysql.server start If you got in properly: That’s great! Let’s create our first Database. ② Creating the database you’ll work with. So if you didn’t use Laravel Homestead you’ll have to create your database first. Once you got into your mysql through the commands above it should say: mysql&gt; in the terminal now. Then just write: CREATE DATABASE my_db; where you can write any name instead of my_db. That’s it! ③ Setting up your Laravel settings. In your Laravel project folder there will be a .env file. Open that and look inside, and search for the following part: 123456DB_CONNECTION=mysqlDB_HOST=127.0.0.1DB_PORT=3306DB_DATABASE=homesteadDB_USERNAME=homesteadDB_PASSWORD=secret Even though I didn’t install Laravel through homestead, it has all the ‘homestead’ settings… Here’s what you need to change: Check if the DB_HOST is set to 127.0.0.1 Set the DB_DATABASE to the one you created. In this case my_db Set a preferred DB_USERNAME or try root. Set the DB_PASSWORD to the password for MySQL you choose at the very beginning, when you set up your mysql through homebrew. ④ DONE You’re done. Try opening the terminal again, go to your Laravel project folder and php artisan migrate.]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_LLDB调试]]></title>
    <url>%2Fblog%2FiOS_LLDB%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[#iOS_LLDB调试 断点调试全局断点（Global BreakPoint）有时候在程序出错的时候不能能准确定位到奔溃的那一行代码,而是直接跑到main循环或者Appdelegate里面， 或者会给你这样的提示： 1EXEC_BAD_ACCESS： 自定义快捷键 条件断点 (Condational Breakpoints)NSLog这里我教大家强化你的NSLog,可以用下面的这段宏 12345678910//A better version of NSLog# define NSLog(format, ...) do &#123; \fprintf(stderr, \&quot;&amp;lt;%s : %d&gt; %s\n\&quot;, \[[[NSString stringWithUTF8String:**FILE**] lastPathComponent] UTF8String], \**LINE**, **func**); \(NSLog)((format), ##**VA_ARGS**); \fprintf(stderr, \&quot;-------\n\&quot;); \&#125; while (0) 这样打印出来的东西才像话嘛(其实NSLog的打印是非常低效的，甚至比print低100倍.使用objc语言(强类型)并且用NSLog打印的时候，常常搞不清楚NSLog(@“%?”,xxx) xxx这种类型该是什么什么类型输出，应该是%d呢还是%@亦或是%f？？？傻傻分不清楚~，所以玩转NSLog你应该要知道以下这几个全局方法！ 开启僵尸对象(Enable NSZombie Objects)Xcode可以把那些已经release掉得对象，变成“僵尸”，当我们访问一个Zombie对象时，Xcode可以告诉我们正在访问的对象是一个不应该存在的对象了。因为Xcode知道这个对象是什么，所以可以让我们知道这个对象在哪里，以及这是什么时候发生的。 所以Zombies可以让你输出的信息更具体！！ 僵尸只能用在模拟器和OC语言LLDB 调试讲解LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。 你可能从未使用过LLDB，那让我们先来热热身。 在调试器中最常用到的命令是p（用于输出基本类型）或者po（用于输出 Objective-C 对象 help 命令最简单命令是 help，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 help 来了解更多细节，例如 help print 或者 help thread。如果你甚至忘记了 help 命令是做什么的，你可以试试 help help。不过你如果知道这么做，那就说明你大概还没有忘光这个命令。 print 命令打印值很简单；只要试试 print 命令: expression 命令如果想改变一个值怎么办？你或许会猜 modify。其实这时候我们要用到的是 expression 这个方便的命令。这不仅会改变调试器中的值，实际上它改变了程序中的值。 expr 命令可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。很明显可以看出，变量a的值被改变。 除此之外，还可以使用这个命令新声明一个变量对象，如： bt 命令其他命令1234567891011121314151617181920212223break NUM 在指定的行上设置断点。bt 显示所有的调用栈帧。该命令可用来显示函数的调用顺序。clear 删除设置在特定源文件、特定行上的断点。其用法为：clear FILENAME:NUM。continue 继续执行正在调试的程序。该命令用在程序由于处理信号或断点而导致停止运行时。display EXPR 每次程序停止后显示表达式的值。表达式由程序定义的变量组成。file FILE 装载指定的可执行文件进行调试。help NAME 显示指定命令的帮助信息。info break 显示当前断点清单，包括到达断点处的次数等。info files 显示被调试文件的详细信息。info func 显示所有的函数名称。info local 显示当函数中的局部变量信息。info prog 显示被调试程序的执行状态。info var 显示所有的全局和静态变量名称。kill 终止正被调试的程序。list 显示源代码段。make 在不退出 gdb 的情况下运行 make 工具。next 在不单步执行进入其他函数的情况下，向前执行一行源代码。print EXPR 显示表达式 EXPR 的值。print-object 打印一个对象print (int) name 打印一个类型print-object [artist description] 调用一个函数set artist = @\&quot;test\&quot; 设置变量值whatis 查看变理的数据类型 Chisel插件调试相信每个人或多或少都在用LLDB来调试，比如po一个对象。LLDB的是非常强大的，且有内建的，完整的 Python 支持。今天我们主要介绍一个 facebook 开源的 lldb 插件 Chisel。可以让你的调试更Easy. 源码地址： ChiselChisel 使用 homebrew 来安装，如果你没有安装homebrew, 参考 homebrew。 12brew updatebrew install chisel 安装完成按照安装日志上的提示，在~/.lldbinit文件中添加一行，没有则新建。 提示类似如下： 123==&amp;gt; CaveatsAdd the following line to ~/.lldbinit to load chisel when Xcode launches: command script import /usr/local/opt/chisel/libexec/fblldb.py 做好上面的步骤，然后重启Xcode就可以尝试下了。 Chisel 为lldb提供了新增的便捷命令，是非常实用的命令 pviews 命令这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription] 。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。 123456789(lldb) pviews view&amp;lt;TestView: 0x18df8070; baseClass = UIControl; frame = (144 9; 126 167); layer = &amp;lt;CALayer: 0x18df8150&amp;gt;&amp;gt; | &amp;lt;UIView: 0x18df81d0; frame = (0 0; 126 126); userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x18df8240&amp;gt;&amp;gt; | &amp;lt;UIImageView: 0x18df8330; frame = (0 0; 126 126); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x18df83b0&amp;gt;&amp;gt; | &amp;lt;UILabel: 0x18df8460; frame = (0 135; 126 14); text = &apos;haha&apos;; userInteractionEnabled = NO; layer = &amp;lt;_UILabelLayer: 0x18df7fb0&amp;gt;&amp;gt; | | &amp;lt;_UILabelContentLayer: 0x131a3d50&amp;gt; (layer) | &amp;lt;UILabel: 0x18df8670; frame = (0 155; 126 12); text = &apos;hahaha&apos;; userInteractionEnabled = NO; layer = &amp;lt;_UILabelLayer: 0x18df8730&amp;gt;&amp;gt; | | &amp;lt;_UILabelContentLayer: 0x131bea10&amp;gt; (layer) | &amp;lt;UIImageView: 0x18df88d0; frame = (0 9; 28 27); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = &amp;lt;CALayer: 0x18df8ba0&amp;gt;&amp;gt; pvc 命令这个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy]同样的效果，而且还可以看到 viewController 是否已经 viewDidLoad。 1234567891011121314(lldb) pvc&amp;lt;TabBarController: 0x13772fd0; view = &amp;lt;UILayoutContainerView; 0x151b3a30&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | &amp;lt;UINavigationController: 0x1602b800; view = &amp;lt;UILayoutContainerView; 0x1b00aca0&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | | &amp;lt;FirstViewController: 0x16029c00; view = &amp;lt;UIView; 0x1b01e1c0&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | &amp;lt;UINavigationController: 0x138c5200; view = &amp;lt;UILayoutContainerView; 0x1316a080&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | | &amp;lt;SecondViewController: 0x16030400; view = &amp;lt;UIView; 0x2094b370&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | | | &amp;lt;SecondChildViewController: 0x15af6000; view = &amp;lt;UIView; 0x18d4e650&amp;gt;; frame = (0, 64; 414, 628)&amp;gt; | &amp;lt;UINavigationController: 0x1383ca00; view = &amp;lt;UILayoutContainerView; 0x13180070&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | | &amp;lt;ThirdViewController: 0x138ddc00; view = &amp;lt;UIView; 0x18df6650&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | | | &amp;lt;ThirdChild1ViewController: 0x1393fe00; view = &amp;lt;UIView; 0x131ec000&amp;gt;; frame = (0, 0; 414, 672)&amp;gt; | | | &amp;lt;ThirdChild2ViewController: 0x138dce00; view = &amp;lt;UIView; 0x204075a0&amp;gt;; frame = (414, 0; 414, 672)&amp;gt; | | | &amp;lt;ThirdChild3ViewController: 0x138a8e00; view = &amp;lt;UIView; 0x20426250&amp;gt;; frame = (828, 0; 414, 672)&amp;gt; | &amp;lt;UINavigationController: 0x160eca00; view = &amp;lt;UILayoutContainerView; 0x152f7d90&amp;gt;; frame = (0, 0; 414, 736)&amp;gt; | | &amp;lt;FourViewController: 0x13157cc0; view not loaded&amp;gt; visualize 命令这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。(lldb) visualize imageView fv &amp; fvc 命令fv 和 fvc 这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。 123456789(lldb) fv scrollView0x18d3b8c0 UIScrollView0x137d0c50 UIScrollView0x131b1580 UIScrollView0x131b2070 UIScrollView(lldb) fvc Home0x1393fe00 HomeFeedsViewController0x138a8e00 HomeFeedsViewController(lldb) show &amp; hide 命令这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。 mask/umask border/unborder 命令这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view. caflush 命令这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。例, 其中 $122 即是目标UIView： 1234(lldb) p view(long) $122 = 140718754142192(lldb) e (void)[$122 setBackgroundColor:[UIColor greenColor]](lldb) caflush bmessage 命令这个命令就是用来打断点用的了，虽然大家断点可能都喜欢在图形界面里面打，但是考虑一种情况：我们想在 [MyViewController viewWillAppear:] 里面打断点，但是MyViewController并没有实现 viewWillAppear: 方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： 1(lldb) bmessage -[MyViewController viewWillAppear:] 上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件： 1[self isKindOfClass:[MyViewController class]] 自定义命令我们也可以自定义插件，不过前提是要懂一些 python。 比如设计一个打印keyWindow的windowLevel的命令：创建python脚本文件 /magical/commands/example.py : 1234567891011121314151617181920#!/usr/bin/python# Example file with custom commands, located at /magical/commands/example.pyimport lldbimport fblldbbase as fbdef lldbcommands(): return [ PrintKeyWindowLevel() ]class PrintKeyWindowLevel(fb.FBCommand): def name(self): return &apos;pkeywinlevel&apos; def description(self): return &apos;An incredibly contrived command that prints the window level of the key window.&apos; def run(self, arguments, options): # It&apos;s a good habit to explicitly cast the type of all return # values and arguments. LLDB can&apos;t always find them on its own. lldb.debugger.HandleCommand(&apos;p (CGFloat)[(id)[(id)[UIApplication sharedApplication] keyWindow] windowLevel]&apos;) 其中定义了PrintKeyWindowLevel的类，需要实现 name description run 方法来分别告诉名称、描述、和执行实体。创建好脚本后，然后在前面安装时创建的 ~/.lldbinit文件中添加一行： 1script fblldb.loadCommandsInDirectory(&apos;/magical/commands/&apos;) 参考文献：Chisel官方说明 与调试器共舞 – LLDB 的华尔兹]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ghost_添加Disqus评论框]]></title>
    <url>%2Fblog%2FGhost_%E6%B7%BB%E5%8A%A0Disqus%E8%AF%84%E8%AE%BA%E6%A1%86%2F</url>
    <content type="text"><![CDATA[#Ghost_添加Disqus评论框 ####添加Disqus的评论框先需要注册一个 Disqus 账号，并且将网站注册到 Disqus 上，可以在 这里 注册自己的网站。 在这一步需要记录下的是那个独一无二的链接所填写的部分，比如我现在的是 alkaliner ，通过这个链接可以直接访问管理面板。点击 完成注册 后会跳转到一个配置页面，可以选择所用的程序，并进行添加。你可以发现 天了噜居然没有 Ghost!点开 Universal Code，可以看到通用的代码。当然这个时候还需要打开 Terminal，使用 SSH 连接服务器。 进入 Ghost安装目录/content/themes/casper/，编辑 post.hbs 。（这里以默认主题为例） 如图所示，在 后插入（注意修改 shortname）： 12345678910111213&lt;div id="disqus_thread"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt; var disqus_shortname = 'alkaliner'; // 注意修改为自己的 shortname var disqus_identifier = '&#123;&#123;post.id&#125;&#125;'; /* * * DON'T EDIT BELOW THIS LINE * * */ (function() &#123; var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); &#125;)();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"http://disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;a href=\"http://disqus.com\" class=\"dsq-brlink\"&gt;comments powered by &lt;span class=\"logo-disqus\"&gt;Disqus&lt;/span&gt;&lt;/a&gt; 保存，退出。截至这里评论框就已经添加好了～具体的效果可以将页面向下滚动，查看详情。 ####有关在首页添加评论计数，可以继续向下：编辑 default.hbs，在 前加入以下内容（注意修改 shortname）： 1234567891011&lt;script type="text/javascript"&gt;/* * * CONFIGURATION VARIABLES * * */var disqus_shortname = 'alkaliner'; // 注意修改为自己的 shortname/* * * DON'T EDIT BELOW THIS LINE * * */(function () &#123; var s = document.createElement('script'); s.async = true; s.type = 'text/javascript'; s.src = '//' + disqus_shortname + '.disqus.com/count.js'; (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);&#125;());&lt;/script&gt; 再编辑 partials/loop.hbs ，如图所示在 中加入： 1&lt;a href=\"&#123;&#123;url&#125;&#125;#disqus_thread\"&gt;Comments&lt;/a&gt; 保存，重启 Ghost 。现在即可在首页看到评论数量。]]></content>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ghost_添加代码高亮]]></title>
    <url>%2Fblog%2FGhost_%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[#Ghost_添加代码高亮 首先做个展示，如下是一段 C# 代码： 123using System;namespace Testhighlight &#123;&#125; 那么，怎么为自己使用的 Ghost 主题添加代码高亮呢？打开 Highlightjs.org 选择你想要安装代码高亮的语言，然后点击 Download。 将下载的 “highlight.zip” 解包并且上传到你的 Ghost 主题文件夹，比如我的是 /ghost/content/themes/casper/assets 打开你喜欢的编辑器，编辑你主题的 “default.hbs” ，在 &lt;head&gt;&lt;/head&gt; 标签之间添加: 123&lt;link rel="stylesheet" href="/assets/css/highlight/monokai_sublime.css" /&gt; &lt;!-- 这里指定的 css 文件是代码高亮的主题，可以根据你的喜好自由选择--&gt; &lt;script src="/assets/js/highlight.pack.js"&gt;&lt;/script&gt; &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 最后：保存你的 “default.hbs” 文件并且上传到服务器，重启你的 Ghost 博客，大功告成。]]></content>
      <tags>
        <tag>Ghost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ghost_开源主题]]></title>
    <url>%2Fblog%2FGhost_%E5%BC%80%E6%BA%90%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[#Ghost_开源主题 ####Yasukohttps://github.com/foru17/Yasuko ####uno-zenhttps://github.com/Kikobeats/uno-zen ####ghost-themeshttps://github.com/haydenbleasel/ghost-themes ####ghostwriterhttps://github.com/roryg/ghostwriter ####ghostiumhttps://github.com/oswaldoacauan/ghostium ####Mapachehttps://github.com/godofredoninja/Mapache ####Vaporhttps://github.com/sethlilly/Vapor]]></content>
      <tags>
        <tag>Ghost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux_Fail2Ban]]></title>
    <url>%2Fblog%2FLinux_Fail2Ban%2F</url>
    <content type="text"><![CDATA[#Linux_Fail2Ban Fail2Ban是一个Python写的安全工具，其用途就是判断是否有人暴力破解密码，是否有人使用DDOS攻击和CC攻击，刚开始也是抱着尝试的心理，根据网上教程总结安装成功，并且配置了邮件报警（需要安装Sendmail），下面来看看效果吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Hi,The IP 43.229.53.43 has just been banned by Fail2Ban after5 attempts against SSH.Here are more information about 43.229.53.43:[Querying whois.v6nic.net][whois.v6nic.net: Name or service not known][Unable to connect to remote host]Regards,Fail2BanHi,The IP 218.65.30.217 has just been banned by Fail2Ban after5 attempts against SSH.Here are more information about 218.65.30.217:[Querying whois.apnic.net][whois.apnic.net]% [whois.apnic.net]% Whois data copyright terms http://www.apnic.net/db/dbcopyright.html% Information related to ‘218.64.0.0 – 218.65.127.255’inetnum: 218.64.0.0 – 218.65.127.255netname: CHINANET-JXcountry: CNdescr: CHINANET jiangxi province networkdescr: China Telecomdescr: No.31,jingrong streetdescr: Beijing 100032admin-c: CH93-APtech-c: JN113-APchanged: hostmaster@cn.net 20020829mnt-by: MAINT-CHINANETmnt-lower: MAINT-IP-WWFstatus: ALLOCATED NON-PORTABLEsource: APNICrole: JXDCB NETaddress: Jiangxi telecom network operation support departmentaddress: No.2009, Beijing East Road , nanchangÃ¯Â¼Âjiangxi provincecountry: CNphone: +86 79186600000e-mail: wzzx_2013@189.cnremarks: send spam reports to wzzx_2013@189.cnremarks: and abuse reports to wzzx_2013@189.cnremarks: http://www.online.jx.cnadmin-c: XY1-APtech-c: WZ1-CNtech-c: WW49-APnic-hdl: JN113-APnotify: wzzx_2013@189.cnmnt-by: MAINT-IP-WWFchanged: hm-changed@apnic.net 20020812changed: chenyiq@gsta.com 20130221source: APNICperson: Chinanet Hostmasternic-hdl: CH93-APe-mail: anti-spam@ns.chinanet.cn.netaddress: No.31 ,jingrong street,beijingaddress: 100032phone: +86-10-58501724fax-no: +86-10-58501724country: CNchanged: dingsy@cndata.com 20070416changed: zhengzm@gsta.com 20140227mnt-by: MAINT-CHINANETsource: APNIC% This query was served by the APNIC Whois Service version 1.69.1-APNICv1r0 (UNDEFINED)Regards,Fail2Ban 还有很多就不列举了，可见还是有人瞄上我了，不过5次尝试就会被ban一天，让他们慢慢穷举去吧！下面介绍怎么安装： 首先配置YUM源： 1vim /etc/yum.repos.d/CentOS-Base.repo 在最后新增： 123456[atrpms]name=Red Hat Enterprise Linux $releasever - $basearch - ATrpmsbaseurl=http://dl.atrpms.net/el$releasever-$basearch/atrpms/stablegpgkey=http://ATrpms.net/RPM-GPG-KEY.atrpmsgpgcheck=1enabled=1 然后执行： 1yum -y install fail2ban 等待安装，几秒钟就安装成功，或者采用RPM安装： 1234567Centos6:rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpmyum install fail2banCentos7:rpm -Uvh http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-2.noarch.rpmyum install fail2ban 安装成功后，服务配置目录为：/etc/fail2ban 12345/etc/fail2ban/action.d #动作文件夹，内含默认文件。iptables以及mail等动作配置/etc/fail2ban/fail2ban.conf #定义了fai2ban日志级别、日志位置及sock文件位置/etc/fail2ban/filter.d #条件文件夹，内含默认文件。过滤日志关键内容设置/etc/fail2ban/jail.conf #主要配置文件，模块化。主要设置启用ban动作的服务及动作阀值/etc/rc.d/init.d/fail2ban #启动脚本文件 其他的默认即可，只需要修改etc/fail2ban/jail.conf文件即可。常用的修改的参数如下： 123456789101112ignoreip = 127.0.0.1 #忽略的IP列表,不受设置限制（白名单）bantime = 600 #屏蔽时间，单位：秒findtime = 600 #这个时间段内超过规定次数会被ban掉maxretry = 3 #最大尝试次数backend = auto #日志修改检测机制（gamin、polling和auto这三种）[ssh] #针对各服务的检查配置，如设置bantime、findtime、maxretry和全局冲突，服务优先级大于全局设置enabled = true #是否激活此项（true/false）filter = sshd #过滤规则filter的名字，对应filter.d目录下的sshd.confaction = iptables[name=SSH, port=ssh, protocol=tcp] #动作的相关参数sendmail-whois[name=SSH, dest=root, sender=fail2ban@example.com] #触发报警的收件人logpath = /var/log/secure #检测的系统的登陆日志文件maxretry = 5 #最大尝试次数 启动Fail2Ban: 12345CentOS 6:service fail2ban restartCentOS 7:systemctl restart fail2ban.service 加入开机启动： 12345CentOS 6:chkconfig fail2ban onCentOS 7:systemctl enable fail2ban 这样就能保证不会被穷举到SSH的密码，当然这个工具是很强大的. 检查fail2ban状态并解禁被锁住的IP地址下面是查看sshd 屏蔽的IP 地址： sudo fail2ban-client status sshd会显示如下信息： 12345678910[root@sdd-15 ~]# sudo fail2ban-client status sshdStatus for the jail: sshd|- Filter| |- Currently failed: 0| |- Total failed: 5| `- File list: /var/log/secure`- Actions |- Currently banned: 1 |- Total banned: 1 `- Banned IP list: 112.14.11.45 解锁特定的IP地址：1sudo fail2ban-client set sshd unbanip 112.14.11.45]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac_Cocoapods安装]]></title>
    <url>%2Fblog%2FMac%20Cocoapods%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[#Mac_Cocoapods安装 1、直接安装命令： 1sudo gem install cocoapods 结果： 1ERROR: Could not find a valid gem &apos;cocoapods&apos; (&amp;gt;= 0) in any repository 办法：需要更新Ruby 2、更新Ruby第一步：切换淘宝的源 命令： 12gem sources --remove https://rubygems.org/gem sources -a http://ruby.taobao.org/ 结果： 12Error fetching http://ruby.taobao.org/: bad response Not Found 404 (http://ruby.taobao.org/specs.4.8.gz) 办法：淘宝的源已经变成了https://ruby.taobao.org/，当然还可以去rubygems官网下载源码安装。 第二步：更新Ruby命令： 1sudo gem update —system 3、安装cocoapods命令： 1sudo gem install cocoapods 结果： 123456789101112131415Fetching: i18n-0.7.0.gem (100%)Successfully installed i18n-0.7.0Fetching: thread_safe-0.3.5.gem (100%)Successfully installed thread_safe-0.3.5Fetching: tzinfo-1.2.2.gem (100%)Successfully installed tzinfo-1.2.2Fetching: minitest-5.8.2.gem (100%)Successfully installed minitest-5.8.2Fetching: activesupport-4.2.4.gem (100%)Successfully installed activesupport-4.2.4Fetching: nap-1.0.0.gem (100%)Successfully installed nap-1.0.0Fetching: fuzzy_match-2.0.4.gem (100%)ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/fuzzy_match 办法： 1sudo gem install -n /usr/local/bin cocoapods]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7_安装配置Redis数据库]]></title>
    <url>%2Fblog%2FCentOS7_%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AERedis%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[#CentOS7_安装配置Redis数据库 Redis就是一种基于key-value的非关系型数据库。这里我将介绍Redis在CentOS 7下如何安装配置。#####1.Redis源码获取 1.进入Redis官网获取Redis最新稳定版下载地址 2.通过wget命令下载 Redis 源代码。 #####2.Redis编译 1.通过tar -xvf redis-3.0.2.tar.gz命令解压下载Redis源码压缩包redis-3.0.2.tar.gz； 2.编译Redis。通过cd redis-3.0.2/进入Redis源码目录内，执行make编译Redis；注意：make命令执行完成编译后，会在src目录下生成6个可执行文件，分别是redis-server、redis-cli、redis-benchmark、redis-check-aof、redis-check-dump、redis-sentinel。 #####3.Redis安装配置 1.安装Redis，执行make install。会将make编译生成的可执行文件拷贝到/usr/local/bin目录下； 2.执行./utils/install_server.sh配置Redis配置之后Redis能随系统启动。 #####4.Redis服务查看、开启、关闭 1.通过ps -ef|grep redis命令查看Redis进程； 2.开启Redis服务操作通过/etc/init.d/redis_6379 start命令，也可通过（service redis_6379 start）； 3.关闭Redis服务操作通过/etc/init.d/redis_6379 stop命令，也可通过（service redis_6379 stop）；]]></content>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS_预搜索关键字高亮]]></title>
    <url>%2Fblog%2FiOS_%E9%A2%84%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE%2F</url>
    <content type="text"><![CDATA[#iOS_预搜索关键字高亮 要实现的效果：1.输入英文不会高亮，或者是输入中文的拼音也不会。2.当有中文的时候会匹配第一个中文，重复的不会被高亮。简单的代码如下，在工程里添加类扩展. NSString+StringToWords.h 1234#import &lt;Foundation/Foundation.h&gt;@interface NSString (StringToWords)-(NSArray*)words;@end NSString+StringToWords.m 12345678910111213141516171819202122232425262728293031323334353637383940#import &quot;NSString+StringToWords.h&quot;@implementation NSString (StringToWords)- (NSArray *)words &#123;#if ! __has_feature(objc_arc) NSMutableArray *words = [[[NSMutableArray alloc] init] autorelease];#else NSMutableArray *words = [[NSMutableArray alloc] init];#endif const char *str = [self cStringUsingEncoding:NSUTF8StringEncoding]; char *word; for (int i = 0; i &lt; strlen(str);) &#123; int len = 0; if (str[i] &gt;= 0xFFFFFFFC) &#123; len = 6; &#125; else if (str[i] &gt;= 0xFFFFFFF8) &#123; len = 5; &#125; else if (str[i] &gt;= 0xFFFFFFF0) &#123; len = 4; &#125; else if (str[i] &gt;= 0xFFFFFFE0) &#123; len = 3; &#125; else if (str[i] &gt;= 0xFFFFFFC0) &#123; len = 2; &#125; else if (str[i] &gt;= 0x00) &#123; len = 1; &#125; word = malloc(sizeof(char) * (len + 1)); for (int j = 0; j &lt; len; j++) &#123; word[j] = str[j + i]; &#125; word[len] = &apos;\\0&apos;; i = i + len; NSString *oneWord = [NSString stringWithCString:word encoding:NSUTF8StringEncoding]; free(word); [words addObject:oneWord]; &#125; return words;&#125;@end 搜索列表用UITableView 实现：在自定义cell中添加如下方法： 1234567891011121314151617181920212223242526272829303132333435- (void)searchListItem:(id)item atIndexPath:(NSIndexPath *)path WithSearchString:(NSString *)searchStr &#123; NSString *resultStr = item[path.row]; NSArray *resultWords = [resultStr words]; NSArray *searchWords = [searchStr words]; NSInteger startNum = 0; NSInteger length = 0;\n NSInteger tempNum = 0; BOOL hasFindFirstChar = YES;\n BOOL isStartNum = YES; for (int i = 0 ; i&lt; searchWords.count; i++) &#123; const char *cString=[searchWords[i] UTF8String]; if (strlen(cString) == 3 &amp;&amp; hasFindFirstChar) &#123; tempNum ++; for (NSInteger j = startNum + length; j&lt;resultWords.count; j++) &#123; if ([searchWords[i] isEqualToString:resultWords[j]]) &#123; if (isStartNum) &#123; startNum = j; isStartNum = NO; length ++; &#125; else &#123; if (j == startNum + tempNum -1) &#123; length++; &#125; &#125; break; &#125; &#125; if (length != tempNum) &#123; hasFindFirstChar = NO; &#125; &#125;else &#123; break; &#125; &#125; NSMutableAttributedString *attributeStr = [[NSMutableAttributedString alloc] initWithString:resultStr]; [attributeStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(startNum,length)]; self.titleLabel.textColor = [UIColor blackColor]; self.titleLabel.attributedText = attributeStr;&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7_加强安全要做的事]]></title>
    <url>%2Fblog%2FCentOS7_%E5%8A%A0%E5%BC%BA%E5%AE%89%E5%85%A8%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[#CentOS7_加强安全要做的事 CentOS 是最多人用来运行服务器的 Linux 版本，最新版本是 CentOS 7。当你兴趣勃勃地在一台主机或 VPS 上安装 CentOS 7 后，首要的工作肯定是加强它的安全性，以下列出的七件事，是你进一步配置系统和安装其他软件前必须做的。 1. 更改 root 密码若果你是自行安装 CentOS 7 的话，安装程序会让你自行设定 root 的密码。不过很多 VPS 服务商只会提供预先安装好的 CentOS 7 映像档，这种情况下他们会透过主控界面告诉你 root 的密码，这个密码的安全性谁也不知道，它是如何产生的呢？随机性可靠吗？复杂性足够吗？服务商的服务器是否记录了密码的副本？我们实在有必要第一时间重设这个密码。 首先使用 ssh 登入服务器，在 Windows 可以使用 Putty、Tera Term、或者在 Cygwin 环境下执行 OpenSSH。在 Mac 和 Linux 上只需在终端机 (terminal) 中执行以下指令便可以了，比 Windows 简单得多： 首次 ssh 到服务器 由于你从来没有使用过 ssh 联系到这台服务器，你的电脑会把服务器的加密公钥下载，然后询问你是否信任它，这台新鲜安装好的 CentOS 7 应该还未引起黑客的兴趣，也不大可能在这么短的时间内被攻陷，所以可以放心接受这个加密公钥。跟着输入 root 的密码登入服务器： 输入 root 密码两次 登入后立即更改 root 的密码，你需要输入新密码两次： 更改 root 密码 好的密码应该同时包含数字、小写英文字母、大写英文字母、和标点符号，最少 15 个字符，这样的密码强度大概有 90 bit，勉强可以应付密码被“暴力破解”，当然我假设了你的密码是真正随机产生，有些人喜欢把个人资料例如名字、出生日期、车牌号码、地址、配偶和子女的名字等等崁入密码中，或者使用字典里的字词拼凑密码，这样密码的强度将会大幅下降，甚至不堪一击，这些问题我曾经在《如何管理密码？》讨论过。 网上有很多随机密码产生器，例如 RANDOM.ORG，大都可用，但记紧必须使用 HTTPS 造访这些网站。如果你有使用“密码夹万”一类的软件，不妨使用它们内建的密码产生器。 完成后不要登出系统，使用另一个视窗用新密码尝试登入，即使失败也可以在原来的视窗重复以上步骤。 2. 新增一个普通帐号这一步连同下一步，相当于为一个城市筑起两道城墙，既可加强防卫，也建立了一道警报机制，当敌人（黑客）卒然来袭，第一道城墙被袭击和破坏，我们还有第二道城墙阻延一下，有时间部署防卫甚至反击。所以这是一个很多人忽略，但其实非常重要的步骤。 首先我们新增一个帐号： 新增一个帐号 这个新帐号 ahhang 没有默认密码，即是说登入 ahhang 时系统不用输入密码！所以我们立即要设定密码： 设定 ahhang 的密码 有些人认为不应该把建立帐号和设定密码两件事分开来做，一来可能会不慎遗忘，二来也给黑客一道时间缝隙登入这个新帐号，所以他们会在 adduser 指令中一并提供加密后的默认密码，方法是加入 -p 参数，不过这样做也有风险，因为黑客可以透过列出系统的进程，得知加密了的新密码，然后把密码破解。 3. 禁止 root 使用 ssh 登入CentOS 7 默认容许任何帐号透过 ssh 登入，包括 root 和一般帐号，为了不让 root 帐号被黑客暴力入侵，我们必须禁止 root 帐号的 ssh 功能，事实上 root 也没有必要 ssh 登入服务器，因为只要使用 su 或 sudo (当然需要输入 root 的密码) 普通帐号便可以拥有 root 的权限。使用 vim (或任何文本编辑器) 开启 /etc/ssh/sshd_config，寻找： 1＃PermitRootLogin yes 修改为： 1PermitRootLogin no 最后输入以下指令重新启动 sshd： 1systemctl restart sshd.service 这样黑客要取得 root 的权限，必须破解 root 和一个普通用户的密码，难度增加了。 完成后不要登出系统，使用另一个视窗尝试登入 root 和普通帐号，测试无误便可进行下一步。 4. 使用非常规的 ssh 端口Ssh 默认使用端口 22，这是在 IANA 注册的官方端口，但没有人说 ssh 不能使用其他端口，很多黑客专门向服务器的 22 端口发动攻击，即使你的服务器固若金汤、牢不可破，但是要系统日以继夜接受攻击，消耗的系统资源（网络、处理器、内存等等）也不会少，何况它是否真的牢不可破还说不定呢！所以有必要让 ssh 使用其他端口，只让有权使用 ssh 的用户知道。 使用 vim (或任何文本编辑器) 开启 /etc/ssh/sshd_config，寻找： 1＃Port 22 修改为： 1Port 10837 你可以把 10837 改为任何 1024 – 65535 之间的任何数字，若果怕与某些系统服务发生冲突，可以参考一下这里。 跟着重新启动 sshd： 1systemctl restart sshd.service 然后是设定防火墙，CentOS 7 的内核已经有防火墙 netfilter，但你的系统未必安装了用户界面，较前版本的 CentOS 默认使用 iptables，但 CentOS 7 开始使用效能更高、稳定性更好的 firewalld，若果服务器尚未安装 firewalld，可以使用以下指令安装，不确定是否已经安装的话也可以输入这个指令，它会告诉你已经安装然后退出。 1yum install firewalld 跟着启动： 1systemctl start firewalld 设定 firewalld 的方法有两个，第一个是修改 firewalld 有关 sshd 的设定，把端口 22 改为 10837，这是正统的做法，但步骤比较多；第二个是要求 firewalld 开启端口 10837，不指定它属于哪一个服务，这个做法通常处理临时的端口开启／封锁，步骤简单，但是日后你要是忘记了这个端口为什么开启了呢？什么时候开启的呢？为了哪一项服务开启呢？可能有点麻烦。我两种方法都会介绍一下，但作为专业的系统管理员（即使不是真正的专业，也应该具备这样的心态），我推荐使用第一种方法。 设定防火墙方法一： 复制 firewalld 有关 sshd 的设定档案： 1cp /usr/lib/firewalld/services/ssh.xml /etc/firewalld/services/ 使用 vim (或任何文本编辑器) 开启 /etc/firewalld/services/ssh.xml，寻找： 1&lt;port protocol=&quot;tcp&quot; port=&quot;22&quot;&gt; 修改为： 1&lt;port protocol=&quot;tcp&quot; port=&quot;10837&quot;/&gt; 储存后重新加载 firewalld： 1firewall-cmd --reload 设定防火墙方法二：输入以下指令： 1firewall-cmd --zone=public --add-port=10837/tcp --permanent 就是这样简单！ 不论使用哪种方法，完成后不要登出系统，使用另一个视窗尝试登入，例如： 1ssh -p 10837 ahhang@192.168.1.188 5. 启用公钥验证登入 ssh现在只有普通帐号才能透过 ssh 登入服务器，但是 ssh 提供一个更先进更安全的验证方法：公钥验证法。 首先每一名用户建立一对加密钥匙（密钥和公钥），密钥储存在日常使用的电脑，公钥则储存在服务器，使用 ssh 联系到服务器的时候，电脑会把一些建立连线请求的资料，其中包括帐号名称和公钥，并且把部分资料用密钥制作数码签署，一股脑儿送到服务器，服务器检查自己的“公钥库”是否包含送来的公钥，有的话再验证数码签署，成功的话便直接登入服务器，无需输入帐号密码。 第一步在日常使用的电脑上使用 ssh-keygen 指令建立一对加密钥匙，它会询问储存加密钥匙的档案名称，和把钥匙加密的密码，档案名称使用默认的路径和名称便可以，密码则无需输入： 建立帐号的 RSA 加密钥匙 这个指令会创造两个档案，一个名为 id_rsa，是你的 RSA 密钥，另一个是 id_rsa.pub，是你的 RSA 公钥。公钥必需上传到服务器并且附加于用户帐号里面的 .ssh/authorized_keys 档案中，这个档案储存所有可透过 ssh 登入到这一个帐号的公钥，一行一条公钥： 上传 RSA 公钥到服务器 顺便一提，这个档案的存取权限必须是 0700，否则 sshd 不会读取： 存放公钥的档案的权限必须是 0700 使用公钥验证法登入 ssh 又省力又安全，因为我们不用输入密码，自然也没有密码被盗取的忧虑，简简单单地输入连线指令便可以了。 但是存放在日常电脑中的密钥却带来新的安全隐患，万一密钥被盗取了，其他人岂不是可以随便登入服务器？现在是“双重验证”(two-factor authentication) 隆重登场的时候，双重验证的理念是我们必须向服务器证明两种不同性质的东西，才能成功验证身分，第一样是我们知道什么，第二样是我们拥有什么。首先服务器会要求我们输入密码，我们知道密码，过了第一关。跟着服务器要求我们证明拥有公钥验证法中的密钥，透过上面的设定程序我们也通过了验证，过了第二关。现在服务器才会让我们进入系统。 设定 ssh 的双重验证法很简单，使用 vim (或任何文本编辑器) 开启 /etc/ssh/sshd_config，在档案的末端假如这一行： 1AuthenticationMethods publickey,password 它告诉服务器用户必须拥有合法的公钥，和输入正确的密码才能成功登入。修改完成后重新启动 sshd： 1systemctl restart sshd.service 完成后不要登出系统，使用另一个视窗尝试登入，测试无误便可进行下一步。 6. 更新、更新、每天更新、每天自动更新每一天都有成千上万的黑客在世界各地寻找 Linux 系统和常见软件的安全漏洞，一有发现便会发动规模庞大而迅速的网络攻击，务求在我们来得及反应前把系统攻陷。不要以为黑客都只是十来岁的年轻小毛头，大部分黑客背后都有势力庞大、资源几乎无限的国家机构支持，有些甚至属于这些机构的雇员，美国的 NSA，英国的 GQHC，中国的无名黑客队伍，都是比较明目张胆由国家支持的网络黑帮，可见我们的系统时时刻刻都被凶狠之徒盯着，保持软件在最新的状态是其中一项我们必须做，也很容易做到的工作。 首先我们立即手动更新所有预先安装的软件： 1yum -y update 跟着设定系统定时自动更新，第一步确定服务器是否安装了自动执行指令的工具，跟着使用 yum 一个名叫 yum-cron 插件。 CentOS 7 使用数个软件来自动执行指令：cron、anacron、at 和 batch，其中 cron 和 anacron 用来定期重复执行指令，At 和 batch 则用来在特定时间执行一次性的指令。我们将会使用 cron 和 anacron，两者的分别这里不细表了，将来有机会再讨论，现在使用以下指令安装 cron 和 anacron： 1yum -y install cronie 下一步就是安装 yum-cron： 1yum -y install yum-cron 其实你可以使用一个指令同时安装 cronie 和 yum-cron，甚至单独安装 yum-cron 也可以，因为 yum 会自动检测到 yum-cron 需要 cronie 然后自动替你安装，上面分开两个指令纯粹令大家容易明白。 完成后系统多了数个档案，比较重要的包括： /etc/cron.daily/0yum.cronAnacron 每天执行这个档案一次，它根据配置档案 /etc/yum/yum-cron.conf 来更新软件/etc/yum/yum-cron.conf这是每天执行 yum-cron 的配置档案，默认只会下载更新的软件，并不安装，用意是让管理员检视 yum-cron 的输出，选取需要更新的软件进行手动安装。跟着我们修改配置档案，让 yum-cron 自动更新软件，使用 vim (或任何文本编辑器) 开启 /etc/yum/yum-cron.conf，寻找： 1apply_updates = no 修改为： 1apply_updates = yes 确认一下 update_messages = yes, download_updates = yes, apply_updates = yes，正如下图： yum-cron 配置档案最后，启动 crond 和 yum-cron： 12systemctl start crondsystemctl start yum-cron 7. 防火墙防火墙的作用好比网络警察，它监察所有进出系统的 IP 封包，哪些端口容许封包进入，哪些端口容许封包外出等等，都由防火墙控制，保护使用这些端口的应用程式，所以设定防火墙是极重要的工作。 过滤封包功能的 netfilter 已经内建在 CentOS 7 的内核，但是配置 netfilter 的界面程式 firewalld 却未必有安装，不论是否已经安装，都可以执行下面的安装指令： 1yum install firewalld 跟着查看一下防火墙现在开启了哪些服务和端口： 1firewall-cmd --list-all 检查防火墙 上图可见防火墙只开启了 DHCP 客户端和 ssh 两个服务的通讯端口，倘若日后安装了其他网络软件，例如网站服务器、域名服务器等等，必须要检查安装程式有否开启他们的通讯端口，没有的话便要手动开启。如果好像前面第四点那样使用了非常规的通讯端口，也可能要手动配置防火墙，防火墙详细的配置方法超出了本文的讨论范围，将来有机会再谈。]]></content>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7_SSH使用证书登录]]></title>
    <url>%2Fblog%2FCentOS7_SSH%E4%BD%BF%E7%94%A8%E8%AF%81%E4%B9%A6%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[#CentOS7_SSH使用证书登录 #####1. 生成用于SSH的公钥和私钥（本例用户为vvusu）1ssh-keygen -t rsa 会提示输入：密钥存放位置（直接回车，默认在/home/vvusu/.ssh/目录）、密码短语、重复密码短语。 完成后在/home/vvusu/.ssh/目录下生成了2个文件：id_rsa为私钥，id_rsa.pub为公钥。 #####2. 导入公钥1cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys #####3. 设置正确的文件和文件夹权限123chown -R 0700 ~/.sshchown -R 0644 ~/.ssh/authorized_keyschown -R ifshow:ifshow /home/ifshow 开启SELinux时，还需要执行（root用户把/home改成/root） 1restorecon -R -v /home #####4. 修改SSH配置文件，支持使用证书登录（root权限）1vi /etc/ssh/sshd_config 查找RSAAuthentication、StrictModes、PubkeyAuthentication、AuthorizedKeysFile把所在行修改为： 1234RSAAuthentication yesStrictModes noPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 重启SSH服务 1systemctl restart sshd.service #####5. Windows客户端配置Putty使用证书登录 5.1 制作用于Putty的私钥 下载id_rsa到本地；运行PuTTY Key Generator；点击File – Load private key（All Files .），导入id_rsa文件；点击Save private key按钮，命名并生成ppk文件，比如ifshow.ppk。这个ppk文件就是用于Putty的私钥。 5.2 设置putty实现用证书登录 Putty→Session：输入Host Name 或者 IP Address；Putty→Connection→Data：输入Auto-login username（自动登陆用户名）；Putty→Connection→SSH→Auth：在Private key file for authentication选择私钥文件；Putty→Session：Saved Session：输入某个名称保存，以后直接双击该名称就可登录。 也可以用带参数的快捷方式执行证书登录，比如： 1&quot;D:\PUTTY\PUTTY.EXE&quot; -i &quot;D:\key\ifshow.ppk&quot; ifshow@xxx.xxx.xxx.xxx #####6. 修改SSH配置文件，禁止使用密码登录（root权限）1vi /etc/ssh/sshd_config 查找PasswordAuthentication yes修改为： 123PasswordAuthentication no //重启SSH服务systemctl restart sshd.service]]></content>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 配置PPTP]]></title>
    <url>%2Fblog%2FLinux_%E9%85%8D%E7%BD%AEPPTP%2F</url>
    <content type="text"><![CDATA[本教程是基于Ubuntu 15.04 版本，主机是Linode提供。 1.登陆主机用ssh命令登陆主机，ssh root@* 表示你的主机IP,后输入密码。 2.更新软件列表，和软件1$ sudo apt-get update 3.安装pptpd $ sudo apt-get install pptpd 编辑配置文件 $ sudo vi /etc/pptpd.conf 找到最下面，修改ip： localip 192.168.13.1 (设置PPTP的IP地址)\nremoteip 192.168.13.50-100,192.168.13.245 (设置PPTP登陆成功后，用户分配到的IP地址区间) 把logwtmp 注掉 要不会提示619错误 4.设置DNS $ sudo vi /etc/ppp/pptpd-options 修改以下部分为google的DNS ms-dns 8.8.8.8\nms-dns 8.8.4.4 5.设置账号 $ sudo vi /etc/ppp/chap-secrets 添加一行，依次为：用户名，服务，密码，限制ip： \&quot;user\&quot; pptpd \&quot;password\&quot; *（*代表不指定IP) 6.重启服务： $ sudo /etc/init.d/pptpd restart 7.设置IP转发 $ sudo vi /etc/sysctl.conf 去掉文件中这一行的注释： net.ipv4.ip_forward=1 (保存并退出) 使它立刻生效： $ sudo sysctl -p 8.安装iptables并设置 $ sudo apt-get install iptables 建立一个NAT： $ sudo iptables -t nat -A POSTROUTING -s 192.168.13.0/24 -o eth0 -j MASQUERADE 将规则保存，使重启后规则不丢失： $ sudo iptables-save &gt;/etc/iptables-rules (若此处提示：-bash: /etc/iptables-rules: Permission denied 则可使用root用户，命令：su - 进入root用户保存) 编辑网卡文件，加载网卡时自动加载规则 $ sudo vi /etc/network/interfaces 末尾加入： iptables-restore &lt;/etc/iptables-rules 设置MTU，防止包过大：1$ iptables -I FORWARD -s 192.168.13.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300 若设置了上条规则，记得保存： $ sudo iptables-save &gt;/etc/iptables-rules 做到这已经完成了配置可以试试连接\n想让pptp开机自动启动可以参考ubuntu常用软件： iptables的一些命令： iptables -L -n -t nat //查看规则 iptables -L -n --line-number //显示行数 iptables -D INPUT //删除规则(INPUT 是类型2是第几行) ######可能遇到的问题 1.Mac上能连接，但没有任何收发包，即能连接上VPN，不能上网：vpn高级里勾选发送全部流量。2.pptpd 链接不上，可能是段口没打开。netstat -ntplpptpd端口为1723]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7_SS-Panel]]></title>
    <url>%2Fblog%2FCentOS7_%E6%90%AD%E5%BB%BAGhost%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[#CentOS7_搭建Ghost博客 初始化VPS刚刚创建CentOS7的时候建议安装yum源。然后再往下继续执行要不有些软件找不到。这里参考 如何添加yum源 先安装依赖文件 123yum update //更新yum源yum groupinstall &quot;Development Tools&quot; //安装开发工具组包yum install wget 配置 MySQL安装mysql 软件 yum install mysql-community-client 安装成功后启动mysql systemctl start mysql ###### 配置mysql sudo mysql_secure_installation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 //输入安装MySQL时的密码，此时为空，直接回车 Enter current password for root (enter for none): OK, successfully used password, moving on... Set root password? [Y/n] //设置root密码 New password: Re-enter new password: Password updated successfully! Reloading privilege tables.. ... Success! Remove anonymous users? [Y/n] //删除匿名用户 ... Success! Disallow root login remotely? [Y/n] //禁止root用户远程登录 ... Success! Remove test database and access to it? [Y/n] //删除默认的 test 数据库， - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reload privilege tables now? [Y/n] //是否马上应用最新的设置 ... Success! Cleaning up... All done! If you&apos;ve completed all of the above steps, your MySQL installation should now be secure. Thanks for using MySQL! ``` 运行上述命令可以进入 MySQL 的交互式安装程序，基本流程是： 1.输入安装 MySQL 时指定的 root 密码，一般直接按回车 2.是否改变 root 密码，输入 y 3.输入新的 root 密码 4.是否删除匿名用户，输入 y 5.是否禁止 root 远程登录，输入 y 6.是否删除默认的 test 数据库，输入 y 7.是否马上应用最新的设置，输入 y 至此，MySQL安装成功。###### 设置字符编码为UTF-8 编辑MySQL的配置文件 vi /etc/my.cnf [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] character-set-server=utf8 1查看是否成功 mysql&gt;;show variables like &apos;char%&apos;;(输入) mysql&gt;;show variables like &apos;collation%&apos;;(输出) 1234###### 登录MySQL 创建数据库，并添加权限&lt;pre&gt;`mysql -uroot -p (你的密码)`&lt;/pre&gt; # 创建名为ghost的用户并新建名为ghost的数据库，同时给ghost用户授予ghost数据库的所有权限 CREATE DATABASE ghost; GRANT ALL PRIVILEGES ON ghost.* To &apos;ghost&apos;@&apos;127.0.0.1&apos; IDENTIFIED BY &apos;为ghost用户设置一个与root不同的密码&apos;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#### 编译安装Node.js方法一： 下载源代码后执行编译和安装。缺点：编译程序往往要消耗很多时间。从官方仓库获得最新的 Node.js 源代码包：wget http://nodejs.org/dist/node-latest.tar.gztar -xzf node-latest.tar.gzcd node-v*编译和安装 Node.js：./configuremakesudo make install完成后我们可以通过 node -v 和 npm -v 命令来检查 Node.js 的版本。方法二：从网络仓库下载已经编译完成的安装包。首先添加仓库：&lt;pre&gt;`curl -sL https://rpm.nodesource.com/setup | bash -`&lt;/pre&gt;直接下载安装 Nodejs：&lt;pre&gt;`yum install -y nodejs`&lt;/pre&gt;分别用 node -v 和 npm -v 检查 Node.js 的版本。(两种方法的最终效果都一样)#### 编译安装Nginx添加Nginx 的源后安装 Nginx&lt;pre&gt;`yum install nginx`&lt;/pre&gt;运行nginx`systemctl start nginx`首先我们安装Nginx启动HTTP服务器,安装成功后输入你的网站IP就可以看到“Welcome to Nginx!”。###### 配置 Nginx 的反向代理前面，如果你已经安装好了 Nginx。修改Nginx代理配置文件,并将代理指向到本地的Ghost端口:sudo vi /etc/nginx/conf.d/default.confserver &#123; listen 80; server_name vvusu.com *.vvusu.com;(填写博客地址) location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:2368; &#125;&#125;重新启动 Nginx 服务器,让设置生效。systemctl restart nginxPS: 关键的工作都已做完了！ 你的博客程序能够跟随操作系统自动运行了。但是别忘了修改服务器时区哦。错误的系统时间会导致博客程序显示错误的文章发布日期。 sudo yun install -y ntp sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Enjoy! 12345678910111213141516171819202122232425262728293031下面是一些常用的 nginx 相关文件地址：1.主配置文件：/etc/nginx/nginx.conf2.默认主机配置文件：/etc/nginx/conf.d/default.conf3.默认日志目录：/var/log/nginx/#### 安装Ghost创建一个文件夹，用来放置网站文件和 Ghost 博客程序。cd /srv/www/从官方网站下载最新版本的 Ghost（ghost-latest.zip）：wget https://ghost.org/zip/ghost-latest.zipunzip -d ghost ghost-latest.zip //解压进入 Ghost 安装目录：cd /srv/www/ghost接下来，进入存放 Ghost 系统的目录并安装 Ghost 所依赖的 npm 包：sudo npm install --production安装完成后用 npm start 命令启动开发者模式下的 Ghost，用于检查有没有安装成功。 成功了，Ghost会运行在本地局域网内 127.0.0.1:2368。如果是在电脑上安装的，用浏览器访问此地址即可预览 Ghost。##### 编辑ghost的配置文件我们进入 Ghost 系统目录，为 Ghost 增加配置文件并配置数据库： cd /srv/www/ghost sudo cp config.example.js config.js sudo vi config.js 1最后一条指令是用 vim 打开 config.js 文件进行编辑。我们只修改 production 一节的配置信息，修改为如下形式（注意按照你自己的实际情况替换！）： # wget https://ghost.org/zip/ghost-latest.zip # unzip ghost-latest.zip -d ghost # npm install --production # mysql -uroot -p -e &apos;create database ghost;&apos; //Ghost默认的是SQLite数据库，但是在各大云平台上都不是太好，这里更换为MariaDB数据库。这里新建一个名为“ghost”的数据库。 # cp config.example.js config.js //备份配置文件 # vi config.js //修改config.js类似于这样 production: { url: &apos;http://vvusu.com&apos;, //你的blog地址 mail: {}, database: { client: &apos;mysql&apos;, connection: { host : &apos;127.0.0.1&apos;, user : &apos;ghost&apos;, //用ghost账户 password : &apos;password&apos;, //你的ghost账户密码 database : &apos;ghost&apos;, charset : &apos;utf8&apos; }, debug: false }, &lt;pre&gt;`server: { // Host to be passed to node&apos;s `net.Server#listen()` host: &apos;127.0.0.1&apos;, // Port to be passed to node&apos;s `net.Server#listen()`, for iisnode set this to `process.env.PORT` port: &apos;2368&apos; } `&lt;/pre&gt; }, 12345678910111213141516171819202122232425262728293031323334353637##### 删除sqlite打开 Ghost 系统的目录下面的 package.json 文件，将 &quot;sqlite3&quot;: &quot;2.2.0&quot;, 这一行删除掉（注意，你看到的 sqlite 版本可能会不一样，但是，只要是 sqlite3 字样，删除即可）。#### 以生产模式运行 Ghost###### 第一种方式但是要部署，我们不能让其运行在开发模式。需要让其运行在生产模式，且当其运行进程退出时自动重启。因此我们可以使用强大的进程守护程序“pm2”达到此目的。（也可以使用Forever）进入到刚才的Ghost安装目录，执行下面的命令安装PM2：sudo npm install pm2 -g我们要设置环境变量为“production”生产模式！“index.js”是程序启动的入口。最后给这个pm2的进程命名为\&quot;ghost\&quot; 于是，执行下面的命令：NODE_ENV=production pm2 start index.js --name &quot;ghost&quot;让PM2知道在开机后自动运行我们的网站：pm2 startup centospm2 save提示: pm2 kill ghost （清除所有ghost进程）pm2 &amp;lt;start|stop|restart&gt;; ghost （启动|停止|重启ghost进程）pm2 startup &amp;lt;centos|ubuntu|amazon&gt;; （让pm2能够在这3个系统上自动启动）至此，pm2 已经可以守护 Ghost 博客永远在线。###### 第二种方式配置**systemd**当我们断开ssh的时候，Node.js的进程也会死掉，所以我们要让Ghost自动重启，官方推荐用forever，如果你想用可以去看看。在这里我们用CentOs 7新的配置工具systemd来守护Ghost，让她死掉后能自动重启。关于systemd请自行Google # vi /etc/systemd/system/ghost.service //添加如下内容 [Service] WorkingDirectory=你的Ghost博客目录 ExecStart=/opt/node-v0.10.30/bin/node index.js Restart=always StandardOutput=syslog StandardError=syslog SyslogIdentifier=ghostblog User=你想运行ghost的用户 Group=组 Environment=PATH=/opt/node-v0.10.30/bin:$PATH Environment=&apos;NODE_ENV=production&apos; [Install] WantedBy=multi-user.target 让Ghost自启动 # systemctl enable ghost # systemctl start ghost # systemctl status ghost 123456789101112131415 ###### 第三种方式 安装forever sudo npm install forever -g 运行ghost cd /srv/www/ghost sudo NODE_ENV=production forever start index.js ##### 遇到的问题###### 主页显示很慢,界面很久才展示出来. 还是因为google被墙了，需要删除三处引用了谷歌字体的地方。/core/server/views 下的两个default.hbs 和 user-error.hbs 以及主题目录content/themes/你的主题/default.hbs中的: 12345###### npm start ghost 正常运行以后，访问ghost， 无法进入后台，web端显示的状态码为302.进入ghost 后台系统会自动检测更新，是否有新版本,但是国内无法访问这个地址 update.ghost.org. 所以你应该在config.js中加入updateCheck: false, 看起来像这样： development: { updateCheck: false, database: { client: &apos;mysql&apos;, connection: { host : &apos;127.0.0.1&apos;, ...... 12###### 如何备份现有的文件？ cp /srv/www/ghost /srv/www/ghost_bak` 这样就可以把原来的文件备份到ghost_bak文件夹. 如何备份数据库？先按cd /srv 进入/srv目录,再mysqldump -uroot -p你的密码 ghost &gt;; ghost.sql这样就会把你的数据库内容备份到srv目录的ghost.sql这个文件里. 参考文献:http://kittenyang.com/myfirstblog/http://undefinedblog.com/centos-installing-ghost/]]></content>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7_添加yum源]]></title>
    <url>%2Fblog%2FCentOS7_%E6%B7%BB%E5%8A%A0yum%E6%BA%90%2F</url>
    <content type="text"><![CDATA[#CentOS7_添加yum源 CentOS 的官方源去掉了一些与版权有关的软件,因此想要安装这些软件或者手动下载安装,或者使用其他源. 首先, 添加源之前要确定系统架构及版本.查看系统版本: CentOS 系统使用以下命令: rpm -q centos-release 会得到如下显示: centos-release-7-1.1503.el7.centos.2.8.x86_64 之后, 要确定系统架构. uname -a 会得到如下显示: Linux li1079-11.members.linode.com 4.1.5-x86_64-linode61 #7 SMP Mon Aug 24 13:46:31 EDT 2015 x86_64 x86_64 x86_64 GNU/Linux x86_64 就是此系统的架构. 知道了系统版本与架构,就可以在源中找到对应的文件导入. 这里介绍几个源: **Remi**, **RPMforge** , **EPEL**, **webtatic** , **Nginx** 如果你是使用的国内主机建议添加国内源如:**网易**,**搜狐**,**中科大**,**中移动**等等. 添加 Remi 源rpm -ivh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm Remi 源包含了众多软件, 它的更新速度很快. 很多新版本的软件都能第一时间在这里找到.进入 [Remi 官网](http://http://rpms.remirepo.net), 找到 Maintained Enterprise Linux (RHEL / CentOS / Other clones) 项,根据系统架构选择相应 release 文件 添加 RPMforge 源&lt;pre&gt;rpm -ivh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm &lt;/pre&gt; 首先到 [RPMforge 网站](http://repoforge.org)找到**usage** 下载对应版本，本地添加。 添加 RPMFusion源[RPMFusion源](http://rpmfusion.org/Configuration)找到对应的版本下载源 rpm - ivh http://download1.rpmfusion.org/free/el/updates/6/i386/rpmfusion-free-release-6-1.noarch.rpm 添加 EPEL 源rpm -ivh http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm 进入网站往下拉, 找到 How can I use these extra packages? 项, 根据系统架构与版本选 EL7, 点击, 系统会根据来访ip查找最快的源镜像, 国内访问通常会转到搜狐与中科大的源.如果想用美国源, 就要使用代理访问. 添加 php 源进入[webtatic.com](http://webtatic.com) ,找到 CentOS/RHEL 7 源并添加. rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 添加 Mysql 源rpm -ivh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm&lt;/pre&gt; 添加 Nginx 源vi /etc/yum.repos.d/nginx.repo 进入 Nginx 官网 , 点右侧的 download 链接, 拉到最下面找到 Pre-Built Packages 项. 点 mainline version 版本的链接. 根据提示编辑 repo 文件的内容, 具体操作如下. 在 yum repo 目录创建新的 nginx.repo 文件输入以下内容 [nginx] name=nginx repo baseurl=http://nginx.org/packages/mainline/centos/7/$basearch/ gpgcheck=0 enabled=1 添加国内的源中科大镜像源rpm -Uvh http://mirrors.ustc.edu.cn/centos/7.0.1406/extras/x86_64/Packages/epel-release-7-5.noarch.rpm 浙大源rpm -Uvh http://mirrors.zju.edu.cn/epel/7/x86_64/e/epel-release-7-5.noarch.rpm 上海交大源rpm -Uvh http://ftp.sjtu.edu.cn/fedora/epel/7/x86_64/e/epel-release-7-5.noarch.rpm sohu镜像源，更新比较慢rpm -Uvh http://mirrors.sohu.com/fedora-epel/7/x86_64/e/epel-release-7-2.noarch.rpm 保存退出 &lt;pre&gt;yum clean all&lt;/pre&gt; 添加源之后更新 yum &lt;pre&gt;yum update&lt;/pre&gt; 最后,需要设置源的管理策略 如果你喜欢优先从某个源安装软件,那么建议安装 yum-priorities 插件 这个插件的作用是给多个源排定优先顺序, 当多个源中存在同一软件的时候, 软件会从优先级最高的源这装. &lt;pre&gt;yum install yum-priorities 安装完后需要设置/etc/yum.repos.d/ 目录下的.repo相关文件（如CentOS-Base.repo），在这些文件中插入顺序指令：priority=N （N为1到99的正整数，数值越小越优先）,例如: 123456789101112131415161718192021[base]name=CentOS-$releasever – Base mirrorlist=http://mirrorlist.CentOS.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=os # baseurl=http://mirror.CentOS.org/CentOS/$releasever/os/$basearch/gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5 priority=1# released updates[updates]name=CentOS-$releasever – Updates mirrorlist=http://mirrorlist.CentOS.org/?release=$releasever&amp;amp;arch=$basearch&amp;amp;repo=updates # baseurl=http://mirror.CentOS.org/CentOS/$releasever/updates/$basearch/gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5 priority=1]]></content>
      <tags>
        <tag>CentOS7</tag>
      </tags>
  </entry>
</search>
